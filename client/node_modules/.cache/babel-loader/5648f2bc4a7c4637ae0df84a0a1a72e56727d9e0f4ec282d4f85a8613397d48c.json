{"ast":null,"code":"/**\r\n * 3D Real Estate Management System - Prototype Pattern Implementation\r\n * Definition of Prototype Interface and Entities\r\n */\n\nimport * as THREE from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\nimport * as SkeletonUtils from 'three/examples/jsm/utils/SkeletonUtils';\n\n/**\r\n * Interface Component acting as the Prototype\r\n * All entities must implement a clone() method.\r\n */\n\nclass Wall {\n  constructor(width, height, depth) {\n    this.width = width;\n    this.height = height;\n    this.depth = depth;\n\n    // Initialize shared resources if they don't exist\n    if (!Wall.geometry) {\n      // Create a unit cube that we can scale\n      Wall.geometry = new THREE.BoxGeometry(1, 1, 1);\n    }\n    if (!Wall.material) {\n      Wall.material = new THREE.MeshStandardMaterial({\n        color: 0xf5f5f5,\n        // Off-white\n        roughness: 0.8,\n        side: THREE.DoubleSide\n      });\n    }\n\n    // Use shared geometry/material\n    this.mesh = new THREE.Mesh(Wall.geometry, Wall.material);\n    this.mesh.scale.set(width, height, depth); // Scale to dimensions\n    this.mesh.castShadow = true;\n    this.mesh.receiveShadow = true;\n    this.mesh.userData = {\n      entityId: this.generateId(),\n      type: 'Wall'\n    };\n  }\n  generateId() {\n    return Math.random().toString(36).substr(2, 9);\n  }\n  setPosition(x, y, z) {\n    this.mesh.position.set(x, y, z);\n  }\n  clone() {\n    const clonedWall = new Wall(this.width, this.height, this.depth);\n    clonedWall.mesh.position.copy(this.mesh.position);\n    clonedWall.mesh.rotation.copy(this.mesh.rotation);\n    clonedWall.mesh.userData.entityId = this.generateId();\n    return clonedWall;\n  }\n  dispose() {\n    // We do NOT dispose static geometry/material here as they are shared.\n    // Only dispose if we created unique materials per instance (not the case here yet).\n  }\n}\n// Static resources to be shared across all Wall instances\nWall.geometry = null;\nWall.material = null;\nclass Furniture {\n  constructor(name, type, modelUrl = null) {\n    this.name = name;\n    this.type = type;\n    this.modelUrl = modelUrl;\n\n    // Init Shared Placeholder Resources\n    if (!Furniture.placeholderGeometry) {\n      Furniture.placeholderGeometry = new THREE.BoxGeometry(2, 2, 2);\n    }\n    if (!Furniture.placeholderMaterial) {\n      Furniture.placeholderMaterial = new THREE.MeshStandardMaterial({\n        color: 0x888888\n      });\n    }\n\n    // Default Mesh (Box) until model is loaded\n    this.mesh = new THREE.Mesh(Furniture.placeholderGeometry, Furniture.placeholderMaterial);\n    this.mesh.castShadow = true;\n    this.mesh.receiveShadow = true;\n    this.mesh.userData = {\n      entityId: this.generateId(),\n      type: 'Furniture',\n      name: name\n    };\n    this.root = new THREE.Group();\n    this.root.add(this.mesh); // Add placeholder initially\n    this.root.userData = {\n      entityId: this.generateId(),\n      type: 'Furniture',\n      name: name\n    };\n  }\n  generateId() {\n    return Math.random().toString(36).substr(2, 9);\n  }\n  setPosition(x, y, z) {\n    this.root.position.set(x, y, z);\n  }\n  setScale(x, y, z) {\n    this.root.scale.set(x, y, z);\n  }\n  setRotation(x, y, z) {\n    this.root.rotation.set(x, y, z);\n  }\n\n  /**\r\n   * Async Load Model\r\n   */\n  async loadModel(loader) {\n    if (!this.modelUrl) return;\n    try {\n      const gltf = await loader.loadAsync(this.modelUrl);\n      const model = gltf.scene;\n\n      // Enable shadows\n      model.traverse(node => {\n        if (node.isMesh) {\n          node.castShadow = true;\n          node.receiveShadow = true;\n        }\n      });\n\n      // --- NORMALIZATION START ---\n      // Auto-Center and normalize scale to fit in a 1x1x1 box roughly, then apply this.scale.\n      // This prevents giant models from \"exploding\" the view.\n\n      const box = new THREE.Box3().setFromObject(model);\n      const size = new THREE.Vector3();\n      box.getSize(size);\n      const center = new THREE.Vector3();\n      box.getCenter(center);\n\n      // Center the model geometry\n      model.position.sub(center);\n      // Important: we shift the internal model, so the parent 'root' position is still valid.\n\n      // Optional: Auto-scale if model is huge or tiny\n      // Let's normalize it so the largest dimension is approx 1 unit, \n      // then we rely on this.root.scale to size it up to real-world meters.\n      // However, our JSON scale is roughly \"meters\" if the base is 1.\n      // Most GLTF models are in meters, but some are millimeters or arbitrary.\n\n      // Heuristic: If largest dim > 10, it's probably wrong scale (mm), or huge building.\n      // If < 0.1, it's probably too small.\n      // For safety in this demo, let's normalize base to max dim = 1.\n\n      const maxDim = Math.max(size.x, size.y, size.z);\n      if (maxDim > 0) {\n        const scaleFactor = 1.0 / maxDim;\n        model.scale.multiplyScalar(scaleFactor);\n      }\n\n      // --- NORMALIZATION END ---\n\n      // Replace placeholder with real model\n      this.root.remove(this.mesh);\n      this.root.add(model);\n      this.mesh = model;\n      console.log(`Loaded and normalized model for ${this.name}`);\n    } catch (err) {\n      console.error(`Failed to load model for ${this.name}`, err);\n    }\n  }\n\n  /**\r\n   * Factory method to create instance from JSON data\r\n   */\n  static fromJSON(data) {\n    const furniture = new Furniture(data.name, data.type, data.modelUrl);\n    if (data.position) furniture.setPosition(data.position.x, data.position.y, data.position.z);\n    if (data.rotation) furniture.setRotation(data.rotation.x, data.rotation.y, data.rotation.z);\n    if (data.scale) furniture.setScale(data.scale.x, data.scale.y, data.scale.z);\n    return furniture;\n  }\n\n  /**\r\n   * Deep Clone\r\n   */\n  clone() {\n    // Create new instance with same metadata\n    const clonedFurniture = new Furniture(this.name, this.type, this.modelUrl);\n\n    // Deep Clone the visual root using SkeletonUtils for GLTF support\n    const clonedRoot = SkeletonUtils.clone(this.root);\n    clonedFurniture.root = clonedRoot;\n\n    // IMPORTANT: Update unique ID\n    clonedFurniture.root.userData.entityId = this.generateId();\n    clonedFurniture.root.userData.type = 'Furniture';\n    clonedFurniture.root.userData.name = this.name;\n    return clonedFurniture;\n  }\n  dispose() {\n    // If the mesh is NOT the shared placeholder, it's a loaded model -> dipose it\n    if (this.mesh && this.mesh !== Furniture.placeholderGeometry && this.modelUrl) {\n      this.mesh.traverse(node => {\n        if (node.isMesh) {\n          if (node.geometry) node.geometry.dispose();\n          if (node.material) {\n            if (Array.isArray(node.material)) {\n              node.material.forEach(m => m.dispose());\n            } else {\n              node.material.dispose();\n            }\n          }\n        }\n      });\n    }\n  }\n}\n// Shared placeholder resources\nFurniture.placeholderGeometry = null;\nFurniture.placeholderMaterial = null;\nclass Room {\n  constructor(name, width = 20, depth = 20) {\n    this.name = name;\n    this.width = width;\n    this.depth = depth;\n    this.furnitureList = [];\n    this.walls = [];\n    this.group = new THREE.Group();\n    this.group.userData = {\n      entityId: this.generateId(),\n      type: 'Room',\n      name: name\n    };\n\n    // Generate Walls automatically\n    this.generateWalls();\n  }\n  generateId() {\n    return Math.random().toString(36).substr(2, 9);\n  }\n  generateWalls() {\n    const h = 3.5; // Wall Height (Increased slightly from 2.5 as requested)\n    const t = 0.5; // Wall Thickness\n\n    // Remove old walls if any\n    this.walls.forEach(w => this.group.remove(w.mesh));\n    this.walls = [];\n\n    // 1. Back Wall\n    const back = new Wall(this.width, h, t);\n    back.setPosition(0, h / 2, -this.depth / 2);\n    this.addWall(back);\n\n    // 2. Front Wall\n    const front = new Wall(this.width, h, t);\n    front.setPosition(0, h / 2, this.depth / 2);\n    this.addWall(front);\n\n    // 3. Left Wall\n    const left = new Wall(t, h, this.depth);\n    left.setPosition(-this.width / 2, h / 2, 0);\n    this.addWall(left);\n\n    // 4. Right Wall\n    const right = new Wall(t, h, this.depth);\n    right.setPosition(this.width / 2, h / 2, 0);\n    this.addWall(right);\n  }\n  addWall(wall) {\n    this.walls.push(wall);\n    this.group.add(wall.mesh);\n  }\n  addFurniture(furniture) {\n    this.furnitureList.push(furniture);\n    this.group.add(furniture.root);\n  }\n\n  /**\r\n   * Factory method to create instance from JSON data\r\n   */\n  static fromJSON(data) {\n    const room = new Room(data.name, data.width, data.depth);\n    if (data.furniture) {\n      data.furniture.forEach(itemData => {\n        const furniture = Furniture.fromJSON(itemData);\n        room.addFurniture(furniture);\n      });\n    }\n    return room;\n  }\n\n  /**\r\n   * Deep Clone\r\n   */\n  clone() {\n    const clonedRoom = new Room(this.name, this.width, this.depth);\n\n    // Clone Furniture\n    this.furnitureList.forEach(item => {\n      const clonedItem = item.clone();\n      clonedRoom.addFurniture(clonedItem);\n    });\n\n    // Copy room transform\n    clonedRoom.group.position.copy(this.group.position);\n    clonedRoom.group.userData.entityId = this.generateId();\n\n    // Note: Walls are generated by constructor, so they are fresh and correct size. \n    // No need to manually clone them unless we support custom wall modifications.\n\n    return clonedRoom;\n  }\n  dispose() {\n    // Dispose walls\n    this.walls.forEach(w => w.dispose());\n    // Dispose furniture\n    this.furnitureList.forEach(f => f.dispose());\n  }\n}\nclass Layout3D {\n  constructor(id, description) {\n    this.id = id;\n    this.description = description;\n    this.rooms = [];\n    this.cameraView = null; // Default camera settings\n    this.group = new THREE.Group();\n    this.group.userData = {\n      entityId: id,\n      type: 'Layout3D',\n      isMaster: true\n    };\n  }\n  addRoom(room) {\n    this.rooms.push(room);\n    this.group.add(room.group);\n  }\n\n  /**\r\n   * Async Load all assets\r\n   */\n  async loadAssets() {\n    const loader = new GLTFLoader();\n    const promises = [];\n    this.rooms.forEach(room => {\n      room.furnitureList.forEach(furniture => {\n        promises.push(furniture.loadModel(loader));\n      });\n    });\n    await Promise.all(promises);\n  }\n  static fromJSON(data) {\n    const layout = new Layout3D(data.id, data.name);\n    if (data.cameraView) {\n      layout.cameraView = data.cameraView;\n    }\n    if (data.rooms) {\n      data.rooms.forEach(roomData => {\n        const room = Room.fromJSON(roomData);\n        layout.addRoom(room);\n      });\n    }\n    return layout;\n  }\n  clone() {\n    const clonedLayout = new Layout3D(this.id, this.description);\n\n    // Copy camera view\n    if (this.cameraView) {\n      clonedLayout.cameraView = {\n        ...this.cameraView\n      };\n    }\n\n    // Deep clone rooms\n    this.rooms.forEach(room => {\n      const clonedRoom = room.clone();\n      clonedLayout.addRoom(clonedRoom);\n    });\n    clonedLayout.group.userData.isMaster = false;\n    return clonedLayout;\n  }\n  dispose() {\n    this.rooms.forEach(r => r.dispose());\n  }\n}\n\n/**\r\n * Prototype Registry\r\n */\nclass LayoutRegistry {\n  constructor() {\n    this.masters = new Map();\n  }\n  registerMaster(id, layout) {\n    console.log(`[Registry] Registering Master Layout: ${id}`);\n    this.masters.set(id, layout);\n  }\n  getSessionClone(id) {\n    const master = this.masters.get(id);\n    if (!master) {\n      throw new Error(`Layout ${id} not found in registry.`);\n    }\n    // console.log(`[Registry] Creating Session Clone for: ${id}`);\n    return master.clone();\n  }\n}\nexport { Furniture, Wall, Room, Layout3D, LayoutRegistry };","map":{"version":3,"names":["THREE","GLTFLoader","SkeletonUtils","Wall","constructor","width","height","depth","geometry","BoxGeometry","material","MeshStandardMaterial","color","roughness","side","DoubleSide","mesh","Mesh","scale","set","castShadow","receiveShadow","userData","entityId","generateId","type","Math","random","toString","substr","setPosition","x","y","z","position","clone","clonedWall","copy","rotation","dispose","Furniture","name","modelUrl","placeholderGeometry","placeholderMaterial","root","Group","add","setScale","setRotation","loadModel","loader","gltf","loadAsync","model","scene","traverse","node","isMesh","box","Box3","setFromObject","size","Vector3","getSize","center","getCenter","sub","maxDim","max","scaleFactor","multiplyScalar","remove","console","log","err","error","fromJSON","data","furniture","clonedFurniture","clonedRoot","Array","isArray","forEach","m","Room","furnitureList","walls","group","generateWalls","h","t","w","back","addWall","front","left","right","wall","push","addFurniture","room","itemData","clonedRoom","item","clonedItem","f","Layout3D","id","description","rooms","cameraView","isMaster","addRoom","loadAssets","promises","Promise","all","layout","roomData","clonedLayout","r","LayoutRegistry","masters","Map","registerMaster","getSessionClone","master","get","Error"],"sources":["C:/Users/chenx/Documents/sda/prototype/client/src/PrototypePattern.js"],"sourcesContent":["/**\r\n * 3D Real Estate Management System - Prototype Pattern Implementation\r\n * Definition of Prototype Interface and Entities\r\n */\r\n\r\nimport * as THREE from 'three';\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\r\nimport * as SkeletonUtils from 'three/examples/jsm/utils/SkeletonUtils';\r\n\r\n/**\r\n * Interface Component acting as the Prototype\r\n * All entities must implement a clone() method.\r\n */\r\n\r\nclass Wall {\r\n    // Static resources to be shared across all Wall instances\r\n    static geometry = null;\r\n    static material = null;\r\n\r\n    constructor(width, height, depth) {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.depth = depth;\r\n\r\n        // Initialize shared resources if they don't exist\r\n        if (!Wall.geometry) {\r\n            // Create a unit cube that we can scale\r\n            Wall.geometry = new THREE.BoxGeometry(1, 1, 1);\r\n        }\r\n        if (!Wall.material) {\r\n            Wall.material = new THREE.MeshStandardMaterial({\r\n                color: 0xf5f5f5, // Off-white\r\n                roughness: 0.8,\r\n                side: THREE.DoubleSide\r\n            });\r\n        }\r\n\r\n        // Use shared geometry/material\r\n        this.mesh = new THREE.Mesh(Wall.geometry, Wall.material);\r\n        this.mesh.scale.set(width, height, depth); // Scale to dimensions\r\n        this.mesh.castShadow = true;\r\n        this.mesh.receiveShadow = true;\r\n        this.mesh.userData = { entityId: this.generateId(), type: 'Wall' };\r\n    }\r\n\r\n    generateId() {\r\n        return Math.random().toString(36).substr(2, 9);\r\n    }\r\n\r\n    setPosition(x, y, z) {\r\n        this.mesh.position.set(x, y, z);\r\n    }\r\n\r\n    clone() {\r\n        const clonedWall = new Wall(this.width, this.height, this.depth);\r\n        clonedWall.mesh.position.copy(this.mesh.position);\r\n        clonedWall.mesh.rotation.copy(this.mesh.rotation);\r\n        clonedWall.mesh.userData.entityId = this.generateId();\r\n        return clonedWall;\r\n    }\r\n\r\n    dispose() {\r\n        // We do NOT dispose static geometry/material here as they are shared.\r\n        // Only dispose if we created unique materials per instance (not the case here yet).\r\n    }\r\n}\r\n\r\nclass Furniture {\r\n    // Shared placeholder resources\r\n    static placeholderGeometry = null;\r\n    static placeholderMaterial = null;\r\n\r\n    constructor(name, type, modelUrl = null) {\r\n        this.name = name;\r\n        this.type = type;\r\n        this.modelUrl = modelUrl;\r\n\r\n        // Init Shared Placeholder Resources\r\n        if (!Furniture.placeholderGeometry) {\r\n            Furniture.placeholderGeometry = new THREE.BoxGeometry(2, 2, 2);\r\n        }\r\n        if (!Furniture.placeholderMaterial) {\r\n            Furniture.placeholderMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });\r\n        }\r\n\r\n        // Default Mesh (Box) until model is loaded\r\n        this.mesh = new THREE.Mesh(Furniture.placeholderGeometry, Furniture.placeholderMaterial);\r\n        this.mesh.castShadow = true;\r\n        this.mesh.receiveShadow = true;\r\n        this.mesh.userData = { entityId: this.generateId(), type: 'Furniture', name: name };\r\n\r\n        this.root = new THREE.Group();\r\n        this.root.add(this.mesh); // Add placeholder initially\r\n        this.root.userData = { entityId: this.generateId(), type: 'Furniture', name: name };\r\n    }\r\n\r\n    generateId() {\r\n        return Math.random().toString(36).substr(2, 9);\r\n    }\r\n\r\n    setPosition(x, y, z) {\r\n        this.root.position.set(x, y, z);\r\n    }\r\n\r\n    setScale(x, y, z) {\r\n        this.root.scale.set(x, y, z);\r\n    }\r\n\r\n    setRotation(x, y, z) {\r\n        this.root.rotation.set(x, y, z);\r\n    }\r\n\r\n    /**\r\n     * Async Load Model\r\n     */\r\n    async loadModel(loader) {\r\n        if (!this.modelUrl) return;\r\n\r\n        try {\r\n            const gltf = await loader.loadAsync(this.modelUrl);\r\n            const model = gltf.scene;\r\n\r\n            // Enable shadows\r\n            model.traverse((node) => {\r\n                if (node.isMesh) {\r\n                    node.castShadow = true;\r\n                    node.receiveShadow = true;\r\n                }\r\n            });\r\n\r\n            // --- NORMALIZATION START ---\r\n            // Auto-Center and normalize scale to fit in a 1x1x1 box roughly, then apply this.scale.\r\n            // This prevents giant models from \"exploding\" the view.\r\n\r\n            const box = new THREE.Box3().setFromObject(model);\r\n            const size = new THREE.Vector3();\r\n            box.getSize(size);\r\n            const center = new THREE.Vector3();\r\n            box.getCenter(center);\r\n\r\n            // Center the model geometry\r\n            model.position.sub(center);\r\n            // Important: we shift the internal model, so the parent 'root' position is still valid.\r\n\r\n            // Optional: Auto-scale if model is huge or tiny\r\n            // Let's normalize it so the largest dimension is approx 1 unit, \r\n            // then we rely on this.root.scale to size it up to real-world meters.\r\n            // However, our JSON scale is roughly \"meters\" if the base is 1.\r\n            // Most GLTF models are in meters, but some are millimeters or arbitrary.\r\n\r\n            // Heuristic: If largest dim > 10, it's probably wrong scale (mm), or huge building.\r\n            // If < 0.1, it's probably too small.\r\n            // For safety in this demo, let's normalize base to max dim = 1.\r\n\r\n            const maxDim = Math.max(size.x, size.y, size.z);\r\n            if (maxDim > 0) {\r\n                const scaleFactor = 1.0 / maxDim;\r\n                model.scale.multiplyScalar(scaleFactor);\r\n            }\r\n\r\n            // --- NORMALIZATION END ---\r\n\r\n            // Replace placeholder with real model\r\n            this.root.remove(this.mesh);\r\n            this.root.add(model);\r\n            this.mesh = model;\r\n\r\n            console.log(`Loaded and normalized model for ${this.name}`);\r\n        } catch (err) {\r\n            console.error(`Failed to load model for ${this.name}`, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Factory method to create instance from JSON data\r\n     */\r\n    static fromJSON(data) {\r\n        const furniture = new Furniture(data.name, data.type, data.modelUrl);\r\n        if (data.position) furniture.setPosition(data.position.x, data.position.y, data.position.z);\r\n        if (data.rotation) furniture.setRotation(data.rotation.x, data.rotation.y, data.rotation.z);\r\n        if (data.scale) furniture.setScale(data.scale.x, data.scale.y, data.scale.z);\r\n        return furniture;\r\n    }\r\n\r\n    /**\r\n     * Deep Clone\r\n     */\r\n    clone() {\r\n        // Create new instance with same metadata\r\n        const clonedFurniture = new Furniture(this.name, this.type, this.modelUrl);\r\n\r\n        // Deep Clone the visual root using SkeletonUtils for GLTF support\r\n        const clonedRoot = SkeletonUtils.clone(this.root);\r\n\r\n        clonedFurniture.root = clonedRoot;\r\n\r\n        // IMPORTANT: Update unique ID\r\n        clonedFurniture.root.userData.entityId = this.generateId();\r\n        clonedFurniture.root.userData.type = 'Furniture';\r\n        clonedFurniture.root.userData.name = this.name;\r\n\r\n        return clonedFurniture;\r\n    }\r\n\r\n    dispose() {\r\n        // If the mesh is NOT the shared placeholder, it's a loaded model -> dipose it\r\n        if (this.mesh && this.mesh !== Furniture.placeholderGeometry && this.modelUrl) {\r\n            this.mesh.traverse((node) => {\r\n                if (node.isMesh) {\r\n                    if (node.geometry) node.geometry.dispose();\r\n                    if (node.material) {\r\n                        if (Array.isArray(node.material)) {\r\n                            node.material.forEach(m => m.dispose());\r\n                        } else {\r\n                            node.material.dispose();\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nclass Room {\r\n    constructor(name, width = 20, depth = 20) {\r\n        this.name = name;\r\n        this.width = width;\r\n        this.depth = depth;\r\n        this.furnitureList = [];\r\n        this.walls = [];\r\n        this.group = new THREE.Group();\r\n        this.group.userData = { entityId: this.generateId(), type: 'Room', name: name };\r\n\r\n        // Generate Walls automatically\r\n        this.generateWalls();\r\n    }\r\n\r\n    generateId() {\r\n        return Math.random().toString(36).substr(2, 9);\r\n    }\r\n\r\n    generateWalls() {\r\n        const h = 3.5; // Wall Height (Increased slightly from 2.5 as requested)\r\n        const t = 0.5; // Wall Thickness\r\n\r\n        // Remove old walls if any\r\n        this.walls.forEach(w => this.group.remove(w.mesh));\r\n        this.walls = [];\r\n\r\n        // 1. Back Wall\r\n        const back = new Wall(this.width, h, t);\r\n        back.setPosition(0, h / 2, -this.depth / 2);\r\n        this.addWall(back);\r\n\r\n        // 2. Front Wall\r\n        const front = new Wall(this.width, h, t);\r\n        front.setPosition(0, h / 2, this.depth / 2);\r\n        this.addWall(front);\r\n\r\n        // 3. Left Wall\r\n        const left = new Wall(t, h, this.depth);\r\n        left.setPosition(-this.width / 2, h / 2, 0);\r\n        this.addWall(left);\r\n\r\n        // 4. Right Wall\r\n        const right = new Wall(t, h, this.depth);\r\n        right.setPosition(this.width / 2, h / 2, 0);\r\n        this.addWall(right);\r\n    }\r\n\r\n    addWall(wall) {\r\n        this.walls.push(wall);\r\n        this.group.add(wall.mesh);\r\n    }\r\n\r\n    addFurniture(furniture) {\r\n        this.furnitureList.push(furniture);\r\n        this.group.add(furniture.root);\r\n    }\r\n\r\n    /**\r\n     * Factory method to create instance from JSON data\r\n     */\r\n    static fromJSON(data) {\r\n        const room = new Room(data.name, data.width, data.depth);\r\n        if (data.furniture) {\r\n            data.furniture.forEach(itemData => {\r\n                const furniture = Furniture.fromJSON(itemData);\r\n                room.addFurniture(furniture);\r\n            });\r\n        }\r\n        return room;\r\n    }\r\n\r\n    /**\r\n     * Deep Clone\r\n     */\r\n    clone() {\r\n        const clonedRoom = new Room(this.name, this.width, this.depth);\r\n\r\n        // Clone Furniture\r\n        this.furnitureList.forEach(item => {\r\n            const clonedItem = item.clone();\r\n            clonedRoom.addFurniture(clonedItem);\r\n        });\r\n\r\n        // Copy room transform\r\n        clonedRoom.group.position.copy(this.group.position);\r\n        clonedRoom.group.userData.entityId = this.generateId();\r\n\r\n        // Note: Walls are generated by constructor, so they are fresh and correct size. \r\n        // No need to manually clone them unless we support custom wall modifications.\r\n\r\n        return clonedRoom;\r\n    }\r\n\r\n    dispose() {\r\n        // Dispose walls\r\n        this.walls.forEach(w => w.dispose());\r\n        // Dispose furniture\r\n        this.furnitureList.forEach(f => f.dispose());\r\n    }\r\n}\r\n\r\nclass Layout3D {\r\n    constructor(id, description) {\r\n        this.id = id;\r\n        this.description = description;\r\n        this.rooms = [];\r\n        this.cameraView = null; // Default camera settings\r\n        this.group = new THREE.Group();\r\n        this.group.userData = { entityId: id, type: 'Layout3D', isMaster: true };\r\n    }\r\n\r\n    addRoom(room) {\r\n        this.rooms.push(room);\r\n        this.group.add(room.group);\r\n    }\r\n\r\n    /**\r\n     * Async Load all assets\r\n     */\r\n    async loadAssets() {\r\n        const loader = new GLTFLoader();\r\n        const promises = [];\r\n\r\n        this.rooms.forEach(room => {\r\n            room.furnitureList.forEach(furniture => {\r\n                promises.push(furniture.loadModel(loader));\r\n            });\r\n        });\r\n\r\n        await Promise.all(promises);\r\n    }\r\n\r\n    static fromJSON(data) {\r\n        const layout = new Layout3D(data.id, data.name);\r\n        if (data.cameraView) {\r\n            layout.cameraView = data.cameraView;\r\n        }\r\n        if (data.rooms) {\r\n            data.rooms.forEach(roomData => {\r\n                const room = Room.fromJSON(roomData);\r\n                layout.addRoom(room);\r\n            });\r\n        }\r\n        return layout;\r\n    }\r\n\r\n    clone() {\r\n        const clonedLayout = new Layout3D(this.id, this.description);\r\n\r\n        // Copy camera view\r\n        if (this.cameraView) {\r\n            clonedLayout.cameraView = { ...this.cameraView };\r\n        }\r\n\r\n        // Deep clone rooms\r\n        this.rooms.forEach(room => {\r\n            const clonedRoom = room.clone();\r\n            clonedLayout.addRoom(clonedRoom);\r\n        });\r\n\r\n        clonedLayout.group.userData.isMaster = false;\r\n\r\n        return clonedLayout;\r\n    }\r\n\r\n    dispose() {\r\n        this.rooms.forEach(r => r.dispose());\r\n    }\r\n}\r\n\r\n/**\r\n * Prototype Registry\r\n */\r\nclass LayoutRegistry {\r\n    constructor() {\r\n        this.masters = new Map();\r\n    }\r\n\r\n    registerMaster(id, layout) {\r\n        console.log(`[Registry] Registering Master Layout: ${id}`);\r\n        this.masters.set(id, layout);\r\n    }\r\n\r\n    getSessionClone(id) {\r\n        const master = this.masters.get(id);\r\n        if (!master) {\r\n            throw new Error(`Layout ${id} not found in registry.`);\r\n        }\r\n        // console.log(`[Registry] Creating Session Clone for: ${id}`);\r\n        return master.clone();\r\n    }\r\n}\r\n\r\nexport {\r\n    Furniture,\r\n    Wall,\r\n    Room,\r\n    Layout3D,\r\n    LayoutRegistry\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}