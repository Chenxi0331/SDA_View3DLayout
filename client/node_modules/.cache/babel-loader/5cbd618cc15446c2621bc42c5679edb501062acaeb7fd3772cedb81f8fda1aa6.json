{"ast":null,"code":"/**\r\n * 3D Real Estate Management System - Prototype Pattern Implementation\r\n * Definition of Prototype Interface and Entities\r\n */\n\nimport * as THREE from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\nimport * as SkeletonUtils from 'three/examples/jsm/utils/SkeletonUtils';\n\n/**\r\n * Interface Component acting as the Prototype\r\n * All entities must implement a clone() method.\r\n */\n\nclass Furniture {\n  constructor(name, type, modelUrl = null) {\n    this.name = name;\n    this.type = type;\n    this.modelUrl = modelUrl;\n\n    // Default Mesh (Box) until model is loaded\n    this.mesh = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), new THREE.MeshStandardMaterial({\n      color: 0x888888\n    }));\n    this.mesh.userData = {\n      entityId: this.generateId(),\n      type: 'Furniture',\n      name: name\n    };\n\n    // If loaded model exists, it will replace/attach to this.mesh or be a child\n    // Better: this.mesh IS the container.\n    // We can swap the content of this.mesh or add the loaded model to it.\n    // Let's make this.mesh a Group if we expect to hold a model.\n    // But for compatibility with existing code which expects a Mesh or Object3D:\n    // Let's use a Group as the root for Furniture now.\n    this.root = new THREE.Group();\n    this.root.add(this.mesh); // Add placeholder initially\n    this.root.userData = {\n      entityId: this.generateId(),\n      type: 'Furniture',\n      name: name\n    };\n  }\n  generateId() {\n    return Math.random().toString(36).substr(2, 9);\n  }\n  setPosition(x, y, z) {\n    this.root.position.set(x, y, z);\n  }\n  setScale(x, y, z) {\n    this.root.scale.set(x, y, z);\n  }\n  setRotation(x, y, z) {\n    this.root.rotation.set(x, y, z);\n  }\n\n  /**\r\n   * Async Load Model\r\n   */\n  async loadModel(loader) {\n    if (!this.modelUrl) return;\n    try {\n      const gltf = await loader.loadAsync(this.modelUrl);\n      const model = gltf.scene;\n\n      // Enable shadows\n      model.traverse(node => {\n        if (node.isMesh) {\n          node.castShadow = true;\n          node.receiveShadow = true;\n        }\n      });\n\n      // Replace placeholder with real model\n      this.root.remove(this.mesh); // Remove box\n      this.root.add(model);\n      this.mesh = model; // Update reference for cloning logic if needed\n\n      console.log(`Loaded model for ${this.name}`);\n    } catch (err) {\n      console.error(`Failed to load model for ${this.name}`, err);\n      // Keep placeholder\n    }\n  }\n\n  /**\r\n   * Factory method to create instance from JSON data\r\n   */\n  static fromJSON(data) {\n    const furniture = new Furniture(data.name, data.type, data.modelUrl);\n    if (data.position) furniture.setPosition(data.position.x, data.position.y, data.position.z);\n    if (data.rotation) furniture.setRotation(data.rotation.x, data.rotation.y, data.rotation.z);\n    if (data.scale) furniture.setScale(data.scale.x, data.scale.y, data.scale.z);\n    return furniture;\n  }\n\n  /**\r\n   * Deep Clone\r\n   */\n  clone() {\n    // Create new instance with same metadata\n    const clonedFurniture = new Furniture(this.name, this.type, this.modelUrl);\n\n    // Deep Clone the visual root using SkeletonUtils for GLTF support\n    // Standard .clone() loses bone connections and animations often.\n    const clonedRoot = SkeletonUtils.clone(this.root);\n    clonedFurniture.root = clonedRoot;\n\n    // IMPORTANT: Update unique ID\n    clonedFurniture.root.userData.entityId = this.generateId();\n    clonedFurniture.root.userData.type = 'Furniture'; // Re-assign if lost\n    clonedFurniture.root.userData.name = this.name;\n    return clonedFurniture;\n  }\n}\nclass Room {\n  constructor(name, width = 20, depth = 20) {\n    this.name = name;\n    this.width = width;\n    this.depth = depth;\n    this.furnitureList = [];\n    this.group = new THREE.Group();\n    this.group.userData = {\n      entityId: this.generateId(),\n      type: 'Room',\n      name: name\n    };\n  }\n  generateId() {\n    return Math.random().toString(36).substr(2, 9);\n  }\n  addFurniture(furniture) {\n    this.furnitureList.push(furniture);\n    this.group.add(furniture.root);\n  }\n\n  /**\r\n   * Factory method to create instance from JSON data\r\n   */\n  static fromJSON(data) {\n    const room = new Room(data.name, data.width, data.depth);\n    if (data.furniture) {\n      data.furniture.forEach(itemData => {\n        const furniture = Furniture.fromJSON(itemData);\n        room.addFurniture(furniture);\n      });\n    }\n    return room;\n  }\n\n  /**\r\n   * Deep Clone\r\n   */\n  clone() {\n    const clonedRoom = new Room(this.name, this.width, this.depth);\n\n    // We don't just clone the group because we want to maintain the Furniture class structure\n    // So we clone the structure manually.\n\n    this.furnitureList.forEach(item => {\n      const clonedItem = item.clone();\n      clonedRoom.addFurniture(clonedItem);\n    });\n\n    // Copy room transform if any\n    clonedRoom.group.position.copy(this.group.position);\n    clonedRoom.group.userData.entityId = this.generateId();\n    return clonedRoom;\n  }\n}\nclass Layout3D {\n  constructor(id, description) {\n    this.id = id;\n    this.description = description;\n    this.rooms = [];\n    this.group = new THREE.Group();\n    this.group.userData = {\n      entityId: id,\n      type: 'Layout3D',\n      isMaster: true\n    };\n  }\n  addRoom(room) {\n    this.rooms.push(room);\n    this.group.add(room.group);\n  }\n\n  /**\r\n   * Async Load all assets\r\n   */\n  async loadAssets() {\n    const loader = new GLTFLoader();\n    const promises = [];\n    this.rooms.forEach(room => {\n      room.furnitureList.forEach(furniture => {\n        promises.push(furniture.loadModel(loader));\n      });\n    });\n    await Promise.all(promises);\n  }\n  static fromJSON(data) {\n    const layout = new Layout3D(data.id, data.name);\n    if (data.rooms) {\n      data.rooms.forEach(roomData => {\n        const room = Room.fromJSON(roomData);\n        layout.addRoom(room);\n      });\n    }\n    return layout;\n  }\n  clone() {\n    const clonedLayout = new Layout3D(this.id, this.description);\n\n    // Deep clone rooms\n    this.rooms.forEach(room => {\n      const clonedRoom = room.clone();\n      clonedLayout.addRoom(clonedRoom);\n    });\n    clonedLayout.group.userData.isMaster = false;\n    return clonedLayout;\n  }\n}\n\n/**\r\n * Prototype Registry\r\n */\nclass LayoutRegistry {\n  constructor() {\n    this.masters = new Map();\n  }\n  registerMaster(id, layout) {\n    console.log(`[Registry] Registering Master Layout: ${id}`);\n    this.masters.set(id, layout);\n  }\n  getSessionClone(id) {\n    const master = this.masters.get(id);\n    if (!master) {\n      throw new Error(`Layout ${id} not found in registry.`);\n    }\n    // console.log(`[Registry] Creating Session Clone for: ${id}`);\n    return master.clone();\n  }\n}\nexport { Furniture, Room, Layout3D, LayoutRegistry };","map":{"version":3,"names":["THREE","GLTFLoader","SkeletonUtils","Furniture","constructor","name","type","modelUrl","mesh","Mesh","BoxGeometry","MeshStandardMaterial","color","userData","entityId","generateId","root","Group","add","Math","random","toString","substr","setPosition","x","y","z","position","set","setScale","scale","setRotation","rotation","loadModel","loader","gltf","loadAsync","model","scene","traverse","node","isMesh","castShadow","receiveShadow","remove","console","log","err","error","fromJSON","data","furniture","clone","clonedFurniture","clonedRoot","Room","width","depth","furnitureList","group","addFurniture","push","room","forEach","itemData","clonedRoom","item","clonedItem","copy","Layout3D","id","description","rooms","isMaster","addRoom","loadAssets","promises","Promise","all","layout","roomData","clonedLayout","LayoutRegistry","masters","Map","registerMaster","getSessionClone","master","get","Error"],"sources":["C:/Users/chenx/Documents/sda/prototype/client/src/PrototypePattern.js"],"sourcesContent":["/**\r\n * 3D Real Estate Management System - Prototype Pattern Implementation\r\n * Definition of Prototype Interface and Entities\r\n */\r\n\r\nimport * as THREE from 'three';\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\r\nimport * as SkeletonUtils from 'three/examples/jsm/utils/SkeletonUtils';\r\n\r\n/**\r\n * Interface Component acting as the Prototype\r\n * All entities must implement a clone() method.\r\n */\r\n\r\nclass Furniture {\r\n    constructor(name, type, modelUrl = null) {\r\n        this.name = name;\r\n        this.type = type;\r\n        this.modelUrl = modelUrl;\r\n\r\n        // Default Mesh (Box) until model is loaded\r\n        this.mesh = new THREE.Mesh(\r\n            new THREE.BoxGeometry(2, 2, 2),\r\n            new THREE.MeshStandardMaterial({ color: 0x888888 })\r\n        );\r\n        this.mesh.userData = { entityId: this.generateId(), type: 'Furniture', name: name };\r\n\r\n        // If loaded model exists, it will replace/attach to this.mesh or be a child\r\n        // Better: this.mesh IS the container.\r\n        // We can swap the content of this.mesh or add the loaded model to it.\r\n        // Let's make this.mesh a Group if we expect to hold a model.\r\n        // But for compatibility with existing code which expects a Mesh or Object3D:\r\n        // Let's use a Group as the root for Furniture now.\r\n        this.root = new THREE.Group();\r\n        this.root.add(this.mesh); // Add placeholder initially\r\n        this.root.userData = { entityId: this.generateId(), type: 'Furniture', name: name };\r\n    }\r\n\r\n    generateId() {\r\n        return Math.random().toString(36).substr(2, 9);\r\n    }\r\n\r\n    setPosition(x, y, z) {\r\n        this.root.position.set(x, y, z);\r\n    }\r\n\r\n    setScale(x, y, z) {\r\n        this.root.scale.set(x, y, z);\r\n    }\r\n\r\n    setRotation(x, y, z) {\r\n        this.root.rotation.set(x, y, z);\r\n    }\r\n\r\n    /**\r\n     * Async Load Model\r\n     */\r\n    async loadModel(loader) {\r\n        if (!this.modelUrl) return;\r\n\r\n        try {\r\n            const gltf = await loader.loadAsync(this.modelUrl);\r\n            const model = gltf.scene;\r\n\r\n            // Enable shadows\r\n            model.traverse((node) => {\r\n                if (node.isMesh) {\r\n                    node.castShadow = true;\r\n                    node.receiveShadow = true;\r\n                }\r\n            });\r\n\r\n            // Replace placeholder with real model\r\n            this.root.remove(this.mesh); // Remove box\r\n            this.root.add(model);\r\n            this.mesh = model; // Update reference for cloning logic if needed\r\n\r\n            console.log(`Loaded model for ${this.name}`);\r\n        } catch (err) {\r\n            console.error(`Failed to load model for ${this.name}`, err);\r\n            // Keep placeholder\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Factory method to create instance from JSON data\r\n     */\r\n    static fromJSON(data) {\r\n        const furniture = new Furniture(data.name, data.type, data.modelUrl);\r\n        if (data.position) furniture.setPosition(data.position.x, data.position.y, data.position.z);\r\n        if (data.rotation) furniture.setRotation(data.rotation.x, data.rotation.y, data.rotation.z);\r\n        if (data.scale) furniture.setScale(data.scale.x, data.scale.y, data.scale.z);\r\n        return furniture;\r\n    }\r\n\r\n    /**\r\n     * Deep Clone\r\n     */\r\n    clone() {\r\n        // Create new instance with same metadata\r\n        const clonedFurniture = new Furniture(this.name, this.type, this.modelUrl);\r\n\r\n        // Deep Clone the visual root using SkeletonUtils for GLTF support\r\n        // Standard .clone() loses bone connections and animations often.\r\n        const clonedRoot = SkeletonUtils.clone(this.root);\r\n\r\n        clonedFurniture.root = clonedRoot;\r\n\r\n        // IMPORTANT: Update unique ID\r\n        clonedFurniture.root.userData.entityId = this.generateId();\r\n        clonedFurniture.root.userData.type = 'Furniture'; // Re-assign if lost\r\n        clonedFurniture.root.userData.name = this.name;\r\n\r\n        return clonedFurniture;\r\n    }\r\n}\r\n\r\nclass Room {\r\n    constructor(name, width = 20, depth = 20) {\r\n        this.name = name;\r\n        this.width = width;\r\n        this.depth = depth;\r\n        this.furnitureList = [];\r\n        this.group = new THREE.Group();\r\n        this.group.userData = { entityId: this.generateId(), type: 'Room', name: name };\r\n    }\r\n\r\n    generateId() {\r\n        return Math.random().toString(36).substr(2, 9);\r\n    }\r\n\r\n    addFurniture(furniture) {\r\n        this.furnitureList.push(furniture);\r\n        this.group.add(furniture.root);\r\n    }\r\n\r\n    /**\r\n     * Factory method to create instance from JSON data\r\n     */\r\n    static fromJSON(data) {\r\n        const room = new Room(data.name, data.width, data.depth);\r\n        if (data.furniture) {\r\n            data.furniture.forEach(itemData => {\r\n                const furniture = Furniture.fromJSON(itemData);\r\n                room.addFurniture(furniture);\r\n            });\r\n        }\r\n        return room;\r\n    }\r\n\r\n    /**\r\n     * Deep Clone\r\n     */\r\n    clone() {\r\n        const clonedRoom = new Room(this.name, this.width, this.depth);\r\n\r\n        // We don't just clone the group because we want to maintain the Furniture class structure\r\n        // So we clone the structure manually.\r\n\r\n        this.furnitureList.forEach(item => {\r\n            const clonedItem = item.clone();\r\n            clonedRoom.addFurniture(clonedItem);\r\n        });\r\n\r\n        // Copy room transform if any\r\n        clonedRoom.group.position.copy(this.group.position);\r\n        clonedRoom.group.userData.entityId = this.generateId();\r\n\r\n        return clonedRoom;\r\n    }\r\n}\r\n\r\nclass Layout3D {\r\n    constructor(id, description) {\r\n        this.id = id;\r\n        this.description = description;\r\n        this.rooms = [];\r\n        this.group = new THREE.Group();\r\n        this.group.userData = { entityId: id, type: 'Layout3D', isMaster: true };\r\n    }\r\n\r\n    addRoom(room) {\r\n        this.rooms.push(room);\r\n        this.group.add(room.group);\r\n    }\r\n\r\n    /**\r\n     * Async Load all assets\r\n     */\r\n    async loadAssets() {\r\n        const loader = new GLTFLoader();\r\n        const promises = [];\r\n\r\n        this.rooms.forEach(room => {\r\n            room.furnitureList.forEach(furniture => {\r\n                promises.push(furniture.loadModel(loader));\r\n            });\r\n        });\r\n\r\n        await Promise.all(promises);\r\n    }\r\n\r\n    static fromJSON(data) {\r\n        const layout = new Layout3D(data.id, data.name);\r\n        if (data.rooms) {\r\n            data.rooms.forEach(roomData => {\r\n                const room = Room.fromJSON(roomData);\r\n                layout.addRoom(room);\r\n            });\r\n        }\r\n        return layout;\r\n    }\r\n\r\n    clone() {\r\n        const clonedLayout = new Layout3D(this.id, this.description);\r\n\r\n        // Deep clone rooms\r\n        this.rooms.forEach(room => {\r\n            const clonedRoom = room.clone();\r\n            clonedLayout.addRoom(clonedRoom);\r\n        });\r\n\r\n        clonedLayout.group.userData.isMaster = false;\r\n\r\n        return clonedLayout;\r\n    }\r\n}\r\n\r\n/**\r\n * Prototype Registry\r\n */\r\nclass LayoutRegistry {\r\n    constructor() {\r\n        this.masters = new Map();\r\n    }\r\n\r\n    registerMaster(id, layout) {\r\n        console.log(`[Registry] Registering Master Layout: ${id}`);\r\n        this.masters.set(id, layout);\r\n    }\r\n\r\n    getSessionClone(id) {\r\n        const master = this.masters.get(id);\r\n        if (!master) {\r\n            throw new Error(`Layout ${id} not found in registry.`);\r\n        }\r\n        // console.log(`[Registry] Creating Session Clone for: ${id}`);\r\n        return master.clone();\r\n    }\r\n}\r\n\r\nexport {\r\n    Furniture,\r\n    Room,\r\n    Layout3D,\r\n    LayoutRegistry\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}