{"ast":null,"code":"import * as helpers from '../ParseHelpers';\nexport default class ThreeDface {\n  constructor() {\n    this.ForEntityName = '3DFACE';\n  }\n  parseEntity(scanner, curr) {\n    const entity = {\n      type: curr.value,\n      vertices: []\n    };\n    curr = scanner.next();\n    while (!scanner.isEOF()) {\n      if (curr.code === 0) break;\n      switch (curr.code) {\n        case 70:\n          // 1 = Closed shape, 128 = plinegen?, 0 = default\n          entity.shape = (curr.value & 1) === 1;\n          entity.hasContinuousLinetypePattern = (curr.value & 128) === 128;\n          break;\n        case 10:\n          // X coordinate of point\n          entity.vertices = parse3dFaceVertices(scanner, curr);\n          curr = scanner.lastReadGroup;\n          break;\n        default:\n          helpers.checkCommonEntityProperties(entity, curr, scanner);\n          break;\n      }\n      curr = scanner.next();\n    }\n    return entity;\n  }\n}\nfunction parse3dFaceVertices(scanner, curr) {\n  var vertices = [];\n  var vertexIsStarted = false;\n  var vertexIsFinished = false;\n  var verticesPer3dFace = 4; // there can be up to four vertices per face, although 3 is most used for TIN\n  for (let i = 0; i <= verticesPer3dFace; i++) {\n    var vertex = {};\n    while (!scanner.isEOF()) {\n      if (curr.code === 0 || vertexIsFinished) break;\n      switch (curr.code) {\n        case 10: // X0\n        case 11: // X1\n        case 12: // X2\n        case 13:\n          // X3\n          if (vertexIsStarted) {\n            vertexIsFinished = true;\n            continue;\n          }\n          vertex.x = curr.value;\n          vertexIsStarted = true;\n          break;\n        case 20: // Y\n        case 21:\n        case 22:\n        case 23:\n          vertex.y = curr.value;\n          break;\n        case 30: // Z\n        case 31:\n        case 32:\n        case 33:\n          vertex.z = curr.value;\n          break;\n        default:\n          // it is possible to have entity codes after the vertices.  \n          // So if code is not accounted for return to entity parser where it might be accounted for\n          return vertices;\n      }\n      curr = scanner.next();\n    }\n    // See https://groups.google.com/forum/#!topic/comp.cad.autocad/9gn8s5O_w6E\n    vertices.push(vertex);\n    vertexIsStarted = false;\n    vertexIsFinished = false;\n  }\n  scanner.rewind();\n  return vertices;\n}\n;","map":{"version":3,"names":["helpers","ThreeDface","constructor","ForEntityName","parseEntity","scanner","curr","entity","type","value","vertices","next","isEOF","code","shape","hasContinuousLinetypePattern","parse3dFaceVertices","lastReadGroup","checkCommonEntityProperties","vertexIsStarted","vertexIsFinished","verticesPer3dFace","i","vertex","x","y","z","push","rewind"],"sources":["C:/Users/chenx/Documents/sda/prototype/client/node_modules/dxf-parser/dist/entities/3dface.js"],"sourcesContent":["import * as helpers from '../ParseHelpers';\nexport default class ThreeDface {\n    constructor() {\n        this.ForEntityName = '3DFACE';\n    }\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value, vertices: [] };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 70: // 1 = Closed shape, 128 = plinegen?, 0 = default\n                    entity.shape = ((curr.value & 1) === 1);\n                    entity.hasContinuousLinetypePattern = ((curr.value & 128) === 128);\n                    break;\n                case 10: // X coordinate of point\n                    entity.vertices = parse3dFaceVertices(scanner, curr);\n                    curr = scanner.lastReadGroup;\n                    break;\n                default:\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\nfunction parse3dFaceVertices(scanner, curr) {\n    var vertices = [];\n    var vertexIsStarted = false;\n    var vertexIsFinished = false;\n    var verticesPer3dFace = 4; // there can be up to four vertices per face, although 3 is most used for TIN\n    for (let i = 0; i <= verticesPer3dFace; i++) {\n        var vertex = {};\n        while (!scanner.isEOF()) {\n            if (curr.code === 0 || vertexIsFinished)\n                break;\n            switch (curr.code) {\n                case 10: // X0\n                case 11: // X1\n                case 12: // X2\n                case 13: // X3\n                    if (vertexIsStarted) {\n                        vertexIsFinished = true;\n                        continue;\n                    }\n                    vertex.x = curr.value;\n                    vertexIsStarted = true;\n                    break;\n                case 20: // Y\n                case 21:\n                case 22:\n                case 23:\n                    vertex.y = curr.value;\n                    break;\n                case 30: // Z\n                case 31:\n                case 32:\n                case 33:\n                    vertex.z = curr.value;\n                    break;\n                default:\n                    // it is possible to have entity codes after the vertices.  \n                    // So if code is not accounted for return to entity parser where it might be accounted for\n                    return vertices;\n            }\n            curr = scanner.next();\n        }\n        // See https://groups.google.com/forum/#!topic/comp.cad.autocad/9gn8s5O_w6E\n        vertices.push(vertex);\n        vertexIsStarted = false;\n        vertexIsFinished = false;\n    }\n    scanner.rewind();\n    return vertices;\n}\n;\n"],"mappings":"AAAA,OAAO,KAAKA,OAAO,MAAM,iBAAiB;AAC1C,eAAe,MAAMC,UAAU,CAAC;EAC5BC,WAAWA,CAAA,EAAG;IACV,IAAI,CAACC,aAAa,GAAG,QAAQ;EACjC;EACAC,WAAWA,CAACC,OAAO,EAAEC,IAAI,EAAE;IACvB,MAAMC,MAAM,GAAG;MAAEC,IAAI,EAAEF,IAAI,CAACG,KAAK;MAAEC,QAAQ,EAAE;IAAG,CAAC;IACjDJ,IAAI,GAAGD,OAAO,CAACM,IAAI,CAAC,CAAC;IACrB,OAAO,CAACN,OAAO,CAACO,KAAK,CAAC,CAAC,EAAE;MACrB,IAAIN,IAAI,CAACO,IAAI,KAAK,CAAC,EACf;MACJ,QAAQP,IAAI,CAACO,IAAI;QACb,KAAK,EAAE;UAAE;UACLN,MAAM,CAACO,KAAK,GAAI,CAACR,IAAI,CAACG,KAAK,GAAG,CAAC,MAAM,CAAE;UACvCF,MAAM,CAACQ,4BAA4B,GAAI,CAACT,IAAI,CAACG,KAAK,GAAG,GAAG,MAAM,GAAI;UAClE;QACJ,KAAK,EAAE;UAAE;UACLF,MAAM,CAACG,QAAQ,GAAGM,mBAAmB,CAACX,OAAO,EAAEC,IAAI,CAAC;UACpDA,IAAI,GAAGD,OAAO,CAACY,aAAa;UAC5B;QACJ;UACIjB,OAAO,CAACkB,2BAA2B,CAACX,MAAM,EAAED,IAAI,EAAED,OAAO,CAAC;UAC1D;MACR;MACAC,IAAI,GAAGD,OAAO,CAACM,IAAI,CAAC,CAAC;IACzB;IACA,OAAOJ,MAAM;EACjB;AACJ;AACA,SAASS,mBAAmBA,CAACX,OAAO,EAAEC,IAAI,EAAE;EACxC,IAAII,QAAQ,GAAG,EAAE;EACjB,IAAIS,eAAe,GAAG,KAAK;EAC3B,IAAIC,gBAAgB,GAAG,KAAK;EAC5B,IAAIC,iBAAiB,GAAG,CAAC,CAAC,CAAC;EAC3B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAID,iBAAiB,EAAEC,CAAC,EAAE,EAAE;IACzC,IAAIC,MAAM,GAAG,CAAC,CAAC;IACf,OAAO,CAAClB,OAAO,CAACO,KAAK,CAAC,CAAC,EAAE;MACrB,IAAIN,IAAI,CAACO,IAAI,KAAK,CAAC,IAAIO,gBAAgB,EACnC;MACJ,QAAQd,IAAI,CAACO,IAAI;QACb,KAAK,EAAE,CAAC,CAAC;QACT,KAAK,EAAE,CAAC,CAAC;QACT,KAAK,EAAE,CAAC,CAAC;QACT,KAAK,EAAE;UAAE;UACL,IAAIM,eAAe,EAAE;YACjBC,gBAAgB,GAAG,IAAI;YACvB;UACJ;UACAG,MAAM,CAACC,CAAC,GAAGlB,IAAI,CAACG,KAAK;UACrBU,eAAe,GAAG,IAAI;UACtB;QACJ,KAAK,EAAE,CAAC,CAAC;QACT,KAAK,EAAE;QACP,KAAK,EAAE;QACP,KAAK,EAAE;UACHI,MAAM,CAACE,CAAC,GAAGnB,IAAI,CAACG,KAAK;UACrB;QACJ,KAAK,EAAE,CAAC,CAAC;QACT,KAAK,EAAE;QACP,KAAK,EAAE;QACP,KAAK,EAAE;UACHc,MAAM,CAACG,CAAC,GAAGpB,IAAI,CAACG,KAAK;UACrB;QACJ;UACI;UACA;UACA,OAAOC,QAAQ;MACvB;MACAJ,IAAI,GAAGD,OAAO,CAACM,IAAI,CAAC,CAAC;IACzB;IACA;IACAD,QAAQ,CAACiB,IAAI,CAACJ,MAAM,CAAC;IACrBJ,eAAe,GAAG,KAAK;IACvBC,gBAAgB,GAAG,KAAK;EAC5B;EACAf,OAAO,CAACuB,MAAM,CAAC,CAAC;EAChB,OAAOlB,QAAQ;AACnB;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}