{"ast":null,"code":"/**\n * DxfArrayScanner\n *\n * Based off the AutoCad 2012 DXF Reference\n * http://images.autodesk.com/adsk/files/autocad_2012_pdf_dxf-reference_enu.pdf\n *\n * Reads through an array representing lines of a dxf file. Takes an array and\n * provides an easy interface to extract group code and value pairs.\n * @param data - an array where each element represents a line in the dxf file\n * @constructor\n */\nexport default class DxfArrayScanner {\n  constructor(data) {\n    this._pointer = 0;\n    this._eof = false;\n    this._data = data;\n  }\n  /**\n   * Gets the next group (code, value) from the array. A group is two consecutive elements\n   * in the array. The first is the code, the second is the value.\n   * @returns {{code: Number}|*}\n   */\n  next() {\n    if (!this.hasNext()) {\n      if (!this._eof) throw new Error('Unexpected end of input: EOF group not read before end of file. Ended on code ' + this._data[this._pointer]);else throw new Error('Cannot call \\'next\\' after EOF group has been read');\n    }\n    const group = {\n      code: parseInt(this._data[this._pointer])\n    };\n    this._pointer++;\n    group.value = parseGroupValue(group.code, this._data[this._pointer].trim());\n    this._pointer++;\n    if (group.code === 0 && group.value === 'EOF') this._eof = true;\n    this.lastReadGroup = group;\n    return group;\n  }\n  peek() {\n    if (!this.hasNext()) {\n      if (!this._eof) throw new Error('Unexpected end of input: EOF group not read before end of file. Ended on code ' + this._data[this._pointer]);else throw new Error('Cannot call \\'next\\' after EOF group has been read');\n    }\n    const group = {\n      code: parseInt(this._data[this._pointer])\n    };\n    group.value = parseGroupValue(group.code, this._data[this._pointer + 1].trim());\n    return group;\n  }\n  rewind(numberOfGroups = 1) {\n    this._pointer = this._pointer - numberOfGroups * 2;\n  }\n  /**\n   * Returns true if there is another code/value pair (2 elements in the array).\n   * @returns {boolean}\n   */\n  hasNext() {\n    // Check if we have read EOF group code\n    if (this._eof) {\n      return false;\n    }\n    // We need to be sure there are two lines available\n    if (this._pointer > this._data.length - 2) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Returns true if the scanner is at the end of the array\n   * @returns {boolean}\n   */\n  isEOF() {\n    return this._eof;\n  }\n}\n/**\n * Parse a value to its proper type.\n * See pages 3 - 10 of the AutoCad DXF 2012 reference given at the top of this file\n *\n * @param code\n * @param value\n * @returns {*}\n */\nfunction parseGroupValue(code, value) {\n  if (code <= 9) return value;\n  if (code >= 10 && code <= 59) return parseFloat(value);\n  if (code >= 60 && code <= 99) return parseInt(value);\n  if (code >= 100 && code <= 109) return value;\n  if (code >= 110 && code <= 149) return parseFloat(value);\n  if (code >= 160 && code <= 179) return parseInt(value);\n  if (code >= 210 && code <= 239) return parseFloat(value);\n  if (code >= 270 && code <= 289) return parseInt(value);\n  if (code >= 290 && code <= 299) return parseBoolean(value);\n  if (code >= 300 && code <= 369) return value;\n  if (code >= 370 && code <= 389) return parseInt(value);\n  if (code >= 390 && code <= 399) return value;\n  if (code >= 400 && code <= 409) return parseInt(value);\n  if (code >= 410 && code <= 419) return value;\n  if (code >= 420 && code <= 429) return parseInt(value);\n  if (code >= 430 && code <= 439) return value;\n  if (code >= 440 && code <= 459) return parseInt(value);\n  if (code >= 460 && code <= 469) return parseFloat(value);\n  if (code >= 470 && code <= 481) return value;\n  if (code === 999) return value;\n  if (code >= 1000 && code <= 1009) return value;\n  if (code >= 1010 && code <= 1059) return parseFloat(value);\n  if (code >= 1060 && code <= 1071) return parseInt(value);\n  console.log('WARNING: Group code does not have a defined type: %j', {\n    code: code,\n    value: value\n  });\n  return value;\n}\n/**\n * Parse a boolean according to a 1 or 0 value\n * @param str\n * @returns {boolean}\n */\nfunction parseBoolean(str) {\n  if (str === '0') return false;\n  if (str === '1') return true;\n  throw TypeError('String \\'' + str + '\\' cannot be cast to Boolean type');\n}","map":{"version":3,"names":["DxfArrayScanner","constructor","data","_pointer","_eof","_data","next","hasNext","Error","group","code","parseInt","value","parseGroupValue","trim","lastReadGroup","peek","rewind","numberOfGroups","length","isEOF","parseFloat","parseBoolean","console","log","str","TypeError"],"sources":["C:/Users/chenx/Documents/sda/prototype/client/node_modules/dxf-parser/dist/DxfArrayScanner.js"],"sourcesContent":["/**\n * DxfArrayScanner\n *\n * Based off the AutoCad 2012 DXF Reference\n * http://images.autodesk.com/adsk/files/autocad_2012_pdf_dxf-reference_enu.pdf\n *\n * Reads through an array representing lines of a dxf file. Takes an array and\n * provides an easy interface to extract group code and value pairs.\n * @param data - an array where each element represents a line in the dxf file\n * @constructor\n */\nexport default class DxfArrayScanner {\n    constructor(data) {\n        this._pointer = 0;\n        this._eof = false;\n        this._data = data;\n    }\n    /**\n     * Gets the next group (code, value) from the array. A group is two consecutive elements\n     * in the array. The first is the code, the second is the value.\n     * @returns {{code: Number}|*}\n     */\n    next() {\n        if (!this.hasNext()) {\n            if (!this._eof)\n                throw new Error('Unexpected end of input: EOF group not read before end of file. Ended on code ' + this._data[this._pointer]);\n            else\n                throw new Error('Cannot call \\'next\\' after EOF group has been read');\n        }\n        const group = {\n            code: parseInt(this._data[this._pointer])\n        };\n        this._pointer++;\n        group.value = parseGroupValue(group.code, this._data[this._pointer].trim());\n        this._pointer++;\n        if (group.code === 0 && group.value === 'EOF')\n            this._eof = true;\n        this.lastReadGroup = group;\n        return group;\n    }\n    peek() {\n        if (!this.hasNext()) {\n            if (!this._eof)\n                throw new Error('Unexpected end of input: EOF group not read before end of file. Ended on code ' + this._data[this._pointer]);\n            else\n                throw new Error('Cannot call \\'next\\' after EOF group has been read');\n        }\n        const group = {\n            code: parseInt(this._data[this._pointer])\n        };\n        group.value = parseGroupValue(group.code, this._data[this._pointer + 1].trim());\n        return group;\n    }\n    rewind(numberOfGroups = 1) {\n        this._pointer = this._pointer - numberOfGroups * 2;\n    }\n    /**\n     * Returns true if there is another code/value pair (2 elements in the array).\n     * @returns {boolean}\n     */\n    hasNext() {\n        // Check if we have read EOF group code\n        if (this._eof) {\n            return false;\n        }\n        // We need to be sure there are two lines available\n        if (this._pointer > this._data.length - 2) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Returns true if the scanner is at the end of the array\n     * @returns {boolean}\n     */\n    isEOF() {\n        return this._eof;\n    }\n}\n/**\n * Parse a value to its proper type.\n * See pages 3 - 10 of the AutoCad DXF 2012 reference given at the top of this file\n *\n * @param code\n * @param value\n * @returns {*}\n */\nfunction parseGroupValue(code, value) {\n    if (code <= 9)\n        return value;\n    if (code >= 10 && code <= 59)\n        return parseFloat(value);\n    if (code >= 60 && code <= 99)\n        return parseInt(value);\n    if (code >= 100 && code <= 109)\n        return value;\n    if (code >= 110 && code <= 149)\n        return parseFloat(value);\n    if (code >= 160 && code <= 179)\n        return parseInt(value);\n    if (code >= 210 && code <= 239)\n        return parseFloat(value);\n    if (code >= 270 && code <= 289)\n        return parseInt(value);\n    if (code >= 290 && code <= 299)\n        return parseBoolean(value);\n    if (code >= 300 && code <= 369)\n        return value;\n    if (code >= 370 && code <= 389)\n        return parseInt(value);\n    if (code >= 390 && code <= 399)\n        return value;\n    if (code >= 400 && code <= 409)\n        return parseInt(value);\n    if (code >= 410 && code <= 419)\n        return value;\n    if (code >= 420 && code <= 429)\n        return parseInt(value);\n    if (code >= 430 && code <= 439)\n        return value;\n    if (code >= 440 && code <= 459)\n        return parseInt(value);\n    if (code >= 460 && code <= 469)\n        return parseFloat(value);\n    if (code >= 470 && code <= 481)\n        return value;\n    if (code === 999)\n        return value;\n    if (code >= 1000 && code <= 1009)\n        return value;\n    if (code >= 1010 && code <= 1059)\n        return parseFloat(value);\n    if (code >= 1060 && code <= 1071)\n        return parseInt(value);\n    console.log('WARNING: Group code does not have a defined type: %j', { code: code, value: value });\n    return value;\n}\n/**\n * Parse a boolean according to a 1 or 0 value\n * @param str\n * @returns {boolean}\n */\nfunction parseBoolean(str) {\n    if (str === '0')\n        return false;\n    if (str === '1')\n        return true;\n    throw TypeError('String \\'' + str + '\\' cannot be cast to Boolean type');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}