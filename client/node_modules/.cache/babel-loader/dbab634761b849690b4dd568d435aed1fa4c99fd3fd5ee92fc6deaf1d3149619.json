{"ast":null,"code":"import DxfParser from 'dxf-parser';\nimport * as THREE from 'three';\n\n// --- Parser ---\nexport class DXFParser {\n  constructor() {\n    this.parser = new DxfParser();\n  }\n  parse(dxfContent) {\n    console.log(`[Parser] Parsing DXF data...`);\n    try {\n      return this.parser.parseSync(dxfContent);\n    } catch (err) {\n      console.error('[Parser] Error parsing DXF:', err);\n      throw err;\n    }\n  }\n}\n\n// --- Reconstruction Engine ---\nexport class ReconstructionEngine {\n  constructor() {\n    this.wallHeight = 2.5;\n    this.wallColor = 0xcccccc;\n  }\n\n  /**\r\n   * Reconstructs 3D layout from a DXF model\r\n   */\n  reconstruct(dxfModel) {\n    console.log(\"[ReconstructionEngine] Reconstructing 3D layout from DXF...\");\n    const group = new THREE.Group();\n    if (!dxfModel || !dxfModel.entities) return group;\n\n    // 1. Calculate Bounding Box for Auto-Scaling\n    let minX = Infinity,\n      minY = Infinity,\n      maxX = -Infinity,\n      maxY = -Infinity;\n    const updateBounds = v => {\n      if (v.x < minX) minX = v.x;\n      if (v.y < minY) minY = v.y;\n      if (v.x > maxX) maxX = v.x;\n      if (v.y > maxY) maxY = v.y;\n    };\n    dxfModel.entities.forEach(entity => {\n      if (entity.vertices) {\n        entity.vertices.forEach(updateBounds);\n      }\n    });\n    if (minX === Infinity) {\n      console.warn(\"No vertices found in DXF entities.\");\n      return group;\n    }\n    const width = maxX - minX;\n    const height = maxY - minY;\n    const centerX = (minX + maxX) / 2;\n    const centerY = (minY + maxY) / 2;\n\n    // Determine scale factor - aim to fit within a ~20 unit area\n    const maxDimension = Math.max(width, height);\n    const scale = maxDimension > 0 ? 20 / maxDimension : 1;\n    console.log(`[ReconstructionEngine] Bounds: [${minX}, ${minY}] to [${maxX}, ${maxY}], Scale: ${scale}`);\n\n    // 2. Create Floor (scaled to fit)\n    const floorGeometry = new THREE.PlaneGeometry(Math.max(width * scale * 1.5, 50), Math.max(height * scale * 1.5, 50));\n    const floorMaterial = new THREE.MeshPhongMaterial({\n      color: 0x333333,\n      side: THREE.DoubleSide\n    });\n    const floor = new THREE.Mesh(floorGeometry, floorMaterial);\n    floor.rotation.x = -Math.PI / 2;\n    floor.position.y = -0.01;\n    group.add(floor);\n\n    // 3. Process DXF Entities with scaling and centering\n    const offsetAndScale = (x, y) => {\n      return {\n        x: (x - centerX) * scale,\n        y: (y - centerY) * scale\n      };\n    };\n    dxfModel.entities.forEach(entity => {\n      if (entity.type === 'LINE') {\n        const v1 = offsetAndScale(entity.vertices[0].x, entity.vertices[0].y);\n        const v2 = offsetAndScale(entity.vertices[1].x, entity.vertices[1].y);\n        this.addWallSegment(v1.x, v1.y, v2.x, v2.y, group);\n      } else if (entity.type === 'LWPOLYLINE' || entity.type === 'POLYLINE') {\n        for (let i = 0; i < entity.vertices.length - 1; i++) {\n          const v1 = offsetAndScale(entity.vertices[i].x, entity.vertices[i].y);\n          const v2 = offsetAndScale(entity.vertices[i + 1].x, entity.vertices[i + 1].y);\n          this.addWallSegment(v1.x, v1.y, v2.x, v2.y, group);\n        }\n        if (entity.shape || entity.closed) {\n          const v1 = offsetAndScale(entity.vertices[entity.vertices.length - 1].x, entity.vertices[entity.vertices.length - 1].y);\n          const v2 = offsetAndScale(entity.vertices[0].x, entity.vertices[0].y);\n          this.addWallSegment(v1.x, v1.y, v2.x, v2.y, group);\n        }\n      }\n    });\n    return group;\n  }\n  addWallSegment(x1, y1, x2, y2, group) {\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const length = Math.sqrt(dx * dx + dy * dy);\n    if (length < 0.001) return;\n    const geometry = new THREE.BoxGeometry(length, this.wallHeight, 0.2);\n    const material = new THREE.MeshPhongMaterial({\n      color: this.wallColor\n    });\n    const wall = new THREE.Mesh(geometry, material);\n\n    // Map DXF XY to 3D XZ (Y is up)\n    // Note: In standard DXF, Y is UP. In Three.js, Y is UP.\n    // But often plans are 2D (Top Down), so DXF X,Y -> Three X, -Z (or Z)\n    // Friend's code used: wall.position.set(midX, height/2, -midY);\n\n    wall.position.set((x1 + x2) / 2, this.wallHeight / 2, -(y1 + y2) / 2);\n    const angle = Math.atan2(-dy, dx);\n    wall.rotation.y = angle;\n    group.add(wall);\n  }\n}\n\n// --- Helper Wrapper for Viewer ---\nexport class ImportedLayout {\n  constructor(group) {\n    this.group = group;\n    this.group.userData.entityId = `dxf-import-${Date.now()}`;\n    this.id = this.group.userData.entityId;\n    // Mock camera view settings used by Viewer\n    this.cameraView = {\n      position: {\n        x: 0,\n        y: 20,\n        z: 20\n      },\n      target: {\n        x: 0,\n        y: 0,\n        z: 0\n      }\n    };\n  }\n  dispose() {\n    console.log(\"Disposing imported layout resources...\");\n    // Traverse and dispose geometries and materials\n    if (this.group) {\n      this.group.traverse(child => {\n        if (child.isMesh) {\n          if (child.geometry) child.geometry.dispose();\n          if (child.material) {\n            if (Array.isArray(child.material)) {\n              child.material.forEach(m => m.dispose());\n            } else {\n              child.material.dispose();\n            }\n          }\n        }\n      });\n    }\n  }\n}","map":{"version":3,"names":["DxfParser","THREE","DXFParser","constructor","parser","parse","dxfContent","console","log","parseSync","err","error","ReconstructionEngine","wallHeight","wallColor","reconstruct","dxfModel","group","Group","entities","minX","Infinity","minY","maxX","maxY","updateBounds","v","x","y","forEach","entity","vertices","warn","width","height","centerX","centerY","maxDimension","Math","max","scale","floorGeometry","PlaneGeometry","floorMaterial","MeshPhongMaterial","color","side","DoubleSide","floor","Mesh","rotation","PI","position","add","offsetAndScale","type","v1","v2","addWallSegment","i","length","shape","closed","x1","y1","x2","y2","dx","dy","sqrt","geometry","BoxGeometry","material","wall","set","angle","atan2","ImportedLayout","userData","entityId","Date","now","id","cameraView","z","target","dispose","traverse","child","isMesh","Array","isArray","m"],"sources":["C:/Users/chenx/Documents/sda/prototype/client/src/DXFReconstruction.js"],"sourcesContent":["import DxfParser from 'dxf-parser';\r\nimport * as THREE from 'three';\r\n\r\n// --- Parser ---\r\nexport class DXFParser {\r\n    constructor() {\r\n        this.parser = new DxfParser();\r\n    }\r\n\r\n    parse(dxfContent) {\r\n        console.log(`[Parser] Parsing DXF data...`);\r\n        try {\r\n            return this.parser.parseSync(dxfContent);\r\n        } catch (err) {\r\n            console.error('[Parser] Error parsing DXF:', err);\r\n            throw err;\r\n        }\r\n    }\r\n}\r\n\r\n// --- Reconstruction Engine ---\r\nexport class ReconstructionEngine {\r\n    constructor() {\r\n        this.wallHeight = 2.5;\r\n        this.wallColor = 0xcccccc;\r\n    }\r\n\r\n    /**\r\n     * Reconstructs 3D layout from a DXF model\r\n     */\r\n    reconstruct(dxfModel) {\r\n        console.log(\"[ReconstructionEngine] Reconstructing 3D layout from DXF...\");\r\n        const group = new THREE.Group();\r\n\r\n        if (!dxfModel || !dxfModel.entities) return group;\r\n\r\n        // 1. Calculate Bounding Box for Auto-Scaling\r\n        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\r\n\r\n        const updateBounds = (v) => {\r\n            if (v.x < minX) minX = v.x;\r\n            if (v.y < minY) minY = v.y;\r\n            if (v.x > maxX) maxX = v.x;\r\n            if (v.y > maxY) maxY = v.y;\r\n        };\r\n\r\n        dxfModel.entities.forEach((entity) => {\r\n            if (entity.vertices) {\r\n                entity.vertices.forEach(updateBounds);\r\n            }\r\n        });\r\n\r\n        if (minX === Infinity) {\r\n             console.warn(\"No vertices found in DXF entities.\");\r\n             return group;\r\n        }\r\n\r\n        const width = maxX - minX;\r\n        const height = maxY - minY;\r\n        const centerX = (minX + maxX) / 2;\r\n        const centerY = (minY + maxY) / 2;\r\n\r\n        // Determine scale factor - aim to fit within a ~20 unit area\r\n        const maxDimension = Math.max(width, height);\r\n        const scale = maxDimension > 0 ? 20 / maxDimension : 1;\r\n\r\n        console.log(`[ReconstructionEngine] Bounds: [${minX}, ${minY}] to [${maxX}, ${maxY}], Scale: ${scale}`);\r\n\r\n        // 2. Create Floor (scaled to fit)\r\n        const floorGeometry = new THREE.PlaneGeometry(Math.max(width * scale * 1.5, 50), Math.max(height * scale * 1.5, 50));\r\n        const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x333333, side: THREE.DoubleSide });\r\n        const floor = new THREE.Mesh(floorGeometry, floorMaterial);\r\n        floor.rotation.x = -Math.PI / 2;\r\n        floor.position.y = -0.01;\r\n        group.add(floor);\r\n\r\n        // 3. Process DXF Entities with scaling and centering\r\n        const offsetAndScale = (x, y) => {\r\n            return {\r\n                x: (x - centerX) * scale,\r\n                y: (y - centerY) * scale\r\n            };\r\n        };\r\n\r\n        dxfModel.entities.forEach((entity) => {\r\n            if (entity.type === 'LINE') {\r\n                const v1 = offsetAndScale(entity.vertices[0].x, entity.vertices[0].y);\r\n                const v2 = offsetAndScale(entity.vertices[1].x, entity.vertices[1].y);\r\n                this.addWallSegment(v1.x, v1.y, v2.x, v2.y, group);\r\n            } else if (entity.type === 'LWPOLYLINE' || entity.type === 'POLYLINE') {\r\n                for (let i = 0; i < entity.vertices.length - 1; i++) {\r\n                    const v1 = offsetAndScale(entity.vertices[i].x, entity.vertices[i].y);\r\n                    const v2 = offsetAndScale(entity.vertices[i + 1].x, entity.vertices[i + 1].y);\r\n                    this.addWallSegment(v1.x, v1.y, v2.x, v2.y, group);\r\n                }\r\n                if (entity.shape || entity.closed) {\r\n                    const v1 = offsetAndScale(entity.vertices[entity.vertices.length - 1].x, entity.vertices[entity.vertices.length - 1].y);\r\n                    const v2 = offsetAndScale(entity.vertices[0].x, entity.vertices[0].y);\r\n                    this.addWallSegment(v1.x, v1.y, v2.x, v2.y, group);\r\n                }\r\n            }\r\n        });\r\n\r\n        return group;\r\n    }\r\n\r\n    addWallSegment(x1, y1, x2, y2, group) {\r\n        const dx = x2 - x1;\r\n        const dy = y2 - y1;\r\n        const length = Math.sqrt(dx * dx + dy * dy);\r\n        if (length < 0.001) return;\r\n\r\n        const geometry = new THREE.BoxGeometry(length, this.wallHeight, 0.2);\r\n        const material = new THREE.MeshPhongMaterial({ color: this.wallColor });\r\n        const wall = new THREE.Mesh(geometry, material);\r\n\r\n        // Map DXF XY to 3D XZ (Y is up)\r\n        // Note: In standard DXF, Y is UP. In Three.js, Y is UP.\r\n        // But often plans are 2D (Top Down), so DXF X,Y -> Three X, -Z (or Z)\r\n        // Friend's code used: wall.position.set(midX, height/2, -midY);\r\n        \r\n        wall.position.set((x1 + x2) / 2, this.wallHeight / 2, -(y1 + y2) / 2);\r\n\r\n        const angle = Math.atan2(-dy, dx);\r\n        wall.rotation.y = angle;\r\n\r\n        group.add(wall);\r\n    }\r\n}\r\n\r\n// --- Helper Wrapper for Viewer ---\r\nexport class ImportedLayout {\r\n    constructor(group) {\r\n        this.group = group;\r\n        this.group.userData.entityId = `dxf-import-${Date.now()}`;\r\n        this.id = this.group.userData.entityId;\r\n        // Mock camera view settings used by Viewer\r\n        this.cameraView = {\r\n            position: { x: 0, y: 20, z: 20 },\r\n            target: { x: 0, y: 0, z: 0 }\r\n        };\r\n    }\r\n    \r\n    dispose() {\r\n        console.log(\"Disposing imported layout resources...\");\r\n        // Traverse and dispose geometries and materials\r\n        if (this.group) {\r\n            this.group.traverse((child) => {\r\n                if (child.isMesh) {\r\n                    if (child.geometry) child.geometry.dispose();\r\n                    if (child.material) {\r\n                        if (Array.isArray(child.material)) {\r\n                            child.material.forEach(m => m.dispose());\r\n                        } else {\r\n                            child.material.dispose();\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}