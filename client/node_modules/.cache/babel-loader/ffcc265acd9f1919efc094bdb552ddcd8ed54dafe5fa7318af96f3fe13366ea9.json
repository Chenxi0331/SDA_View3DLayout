{"ast":null,"code":"import * as helpers from '../ParseHelpers';\nexport default class Lwpolyline {\n  constructor() {\n    this.ForEntityName = 'LWPOLYLINE';\n  }\n  parseEntity(scanner, curr) {\n    const entity = {\n      type: curr.value,\n      vertices: []\n    };\n    let numberOfVertices = 0;\n    curr = scanner.next();\n    while (!scanner.isEOF()) {\n      if (curr.code === 0) break;\n      switch (curr.code) {\n        case 38:\n          entity.elevation = curr.value;\n          break;\n        case 39:\n          entity.depth = curr.value;\n          break;\n        case 70:\n          // 1 = Closed shape, 128 = plinegen?, 0 = default\n          entity.shape = (curr.value & 1) === 1;\n          entity.hasContinuousLinetypePattern = (curr.value & 128) === 128;\n          break;\n        case 90:\n          numberOfVertices = curr.value;\n          break;\n        case 10:\n          // X coordinate of point\n          entity.vertices = parseLWPolylineVertices(numberOfVertices, scanner);\n          break;\n        case 43:\n          if (curr.value !== 0) entity.width = curr.value;\n          break;\n        case 210:\n          entity.extrusionDirectionX = curr.value;\n          break;\n        case 220:\n          entity.extrusionDirectionY = curr.value;\n          break;\n        case 230:\n          entity.extrusionDirectionZ = curr.value;\n          break;\n        default:\n          helpers.checkCommonEntityProperties(entity, curr, scanner);\n          break;\n      }\n      curr = scanner.next();\n    }\n    return entity;\n  }\n}\nfunction parseLWPolylineVertices(n, scanner) {\n  if (!n || n <= 0) throw Error('n must be greater than 0 verticies');\n  const vertices = [];\n  let vertexIsStarted = false;\n  let vertexIsFinished = false;\n  let curr = scanner.lastReadGroup;\n  for (let i = 0; i < n; i++) {\n    const vertex = {};\n    while (!scanner.isEOF()) {\n      if (curr.code === 0 || vertexIsFinished) break;\n      switch (curr.code) {\n        case 10:\n          // X\n          if (vertexIsStarted) {\n            vertexIsFinished = true;\n            continue;\n          }\n          vertex.x = curr.value;\n          vertexIsStarted = true;\n          break;\n        case 20:\n          // Y\n          vertex.y = curr.value;\n          break;\n        case 30:\n          // Z\n          vertex.z = curr.value;\n          break;\n        case 40:\n          // start width\n          vertex.startWidth = curr.value;\n          break;\n        case 41:\n          // end width\n          vertex.endWidth = curr.value;\n          break;\n        case 42:\n          // bulge\n          if (curr.value != 0) vertex.bulge = curr.value;\n          break;\n        default:\n          // if we do not hit known code return vertices.  Code might belong to entity\n          scanner.rewind();\n          if (vertexIsStarted) {\n            vertices.push(vertex);\n          }\n          scanner.rewind();\n          return vertices;\n      }\n      curr = scanner.next();\n    }\n    // See https://groups.google.com/forum/#!topic/comp.cad.autocad/9gn8s5O_w6E\n    vertices.push(vertex);\n    vertexIsStarted = false;\n    vertexIsFinished = false;\n  }\n  scanner.rewind();\n  return vertices;\n}","map":{"version":3,"names":["helpers","Lwpolyline","constructor","ForEntityName","parseEntity","scanner","curr","entity","type","value","vertices","numberOfVertices","next","isEOF","code","elevation","depth","shape","hasContinuousLinetypePattern","parseLWPolylineVertices","width","extrusionDirectionX","extrusionDirectionY","extrusionDirectionZ","checkCommonEntityProperties","n","Error","vertexIsStarted","vertexIsFinished","lastReadGroup","i","vertex","x","y","z","startWidth","endWidth","bulge","rewind","push"],"sources":["C:/Users/chenx/Documents/sda/prototype/client/node_modules/dxf-parser/dist/entities/lwpolyline.js"],"sourcesContent":["import * as helpers from '../ParseHelpers';\nexport default class Lwpolyline {\n    constructor() {\n        this.ForEntityName = 'LWPOLYLINE';\n    }\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value, vertices: [] };\n        let numberOfVertices = 0;\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 38:\n                    entity.elevation = curr.value;\n                    break;\n                case 39:\n                    entity.depth = curr.value;\n                    break;\n                case 70: // 1 = Closed shape, 128 = plinegen?, 0 = default\n                    entity.shape = ((curr.value & 1) === 1);\n                    entity.hasContinuousLinetypePattern = ((curr.value & 128) === 128);\n                    break;\n                case 90:\n                    numberOfVertices = curr.value;\n                    break;\n                case 10: // X coordinate of point\n                    entity.vertices = parseLWPolylineVertices(numberOfVertices, scanner);\n                    break;\n                case 43:\n                    if (curr.value !== 0)\n                        entity.width = curr.value;\n                    break;\n                case 210:\n                    entity.extrusionDirectionX = curr.value;\n                    break;\n                case 220:\n                    entity.extrusionDirectionY = curr.value;\n                    break;\n                case 230:\n                    entity.extrusionDirectionZ = curr.value;\n                    break;\n                default:\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\nfunction parseLWPolylineVertices(n, scanner) {\n    if (!n || n <= 0)\n        throw Error('n must be greater than 0 verticies');\n    const vertices = [];\n    let vertexIsStarted = false;\n    let vertexIsFinished = false;\n    let curr = scanner.lastReadGroup;\n    for (let i = 0; i < n; i++) {\n        const vertex = {};\n        while (!scanner.isEOF()) {\n            if (curr.code === 0 || vertexIsFinished)\n                break;\n            switch (curr.code) {\n                case 10: // X\n                    if (vertexIsStarted) {\n                        vertexIsFinished = true;\n                        continue;\n                    }\n                    vertex.x = curr.value;\n                    vertexIsStarted = true;\n                    break;\n                case 20: // Y\n                    vertex.y = curr.value;\n                    break;\n                case 30: // Z\n                    vertex.z = curr.value;\n                    break;\n                case 40: // start width\n                    vertex.startWidth = curr.value;\n                    break;\n                case 41: // end width\n                    vertex.endWidth = curr.value;\n                    break;\n                case 42: // bulge\n                    if (curr.value != 0)\n                        vertex.bulge = curr.value;\n                    break;\n                default:\n                    // if we do not hit known code return vertices.  Code might belong to entity\n                    scanner.rewind();\n                    if (vertexIsStarted) {\n                        vertices.push(vertex);\n                    }\n                    scanner.rewind();\n                    return vertices;\n            }\n            curr = scanner.next();\n        }\n        // See https://groups.google.com/forum/#!topic/comp.cad.autocad/9gn8s5O_w6E\n        vertices.push(vertex);\n        vertexIsStarted = false;\n        vertexIsFinished = false;\n    }\n    scanner.rewind();\n    return vertices;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}