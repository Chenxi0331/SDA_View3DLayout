{"ast":null,"code":"import DxfArrayScanner from './DxfArrayScanner';\nimport AUTO_CAD_COLOR_INDEX from './AutoCadColorIndex';\nimport Face from './entities/3dface';\nimport Arc from './entities/arc';\nimport AttDef from './entities/attdef';\nimport Circle from './entities/circle';\nimport Dimension from './entities/dimension';\nimport Ellipse from './entities/ellipse';\nimport Insert from './entities/insert';\nimport Line from './entities/line';\nimport LWPolyline from './entities/lwpolyline';\nimport MText from './entities/mtext';\nimport Point from './entities/point';\nimport Polyline from './entities/polyline';\nimport Solid from './entities/solid';\nimport Spline from './entities/spline';\nimport Text from './entities/text';\n//import Vertex from './entities/';\nimport log from 'loglevel';\n//log.setLevel('trace');\n//log.setLevel('debug');\n//log.setLevel('info');\n//log.setLevel('warn');\nlog.setLevel('error');\nfunction registerDefaultEntityHandlers(dxfParser) {\n  // Supported entities here (some entity code is still being refactored into this flow)\n  dxfParser.registerEntityHandler(Face);\n  dxfParser.registerEntityHandler(Arc);\n  dxfParser.registerEntityHandler(AttDef);\n  dxfParser.registerEntityHandler(Circle);\n  dxfParser.registerEntityHandler(Dimension);\n  dxfParser.registerEntityHandler(Ellipse);\n  dxfParser.registerEntityHandler(Insert);\n  dxfParser.registerEntityHandler(Line);\n  dxfParser.registerEntityHandler(LWPolyline);\n  dxfParser.registerEntityHandler(MText);\n  dxfParser.registerEntityHandler(Point);\n  dxfParser.registerEntityHandler(Polyline);\n  dxfParser.registerEntityHandler(Solid);\n  dxfParser.registerEntityHandler(Spline);\n  dxfParser.registerEntityHandler(Text);\n  //dxfParser.registerEntityHandler(require('./entities/vertex'));\n}\nexport default class DxfParser {\n  constructor() {\n    this._entityHandlers = {};\n    registerDefaultEntityHandlers(this);\n  }\n  parse(source) {\n    if (typeof source === 'string') {\n      return this._parse(source);\n    } else {\n      console.error('Cannot read dxf source of type `' + typeof source);\n      return null;\n    }\n  }\n  registerEntityHandler(handlerType) {\n    const instance = new handlerType();\n    this._entityHandlers[instance.ForEntityName] = instance;\n  }\n  parseSync(source) {\n    return this.parse(source);\n  }\n  parseStream(stream) {\n    let dxfString = \"\";\n    const self = this;\n    return new Promise((res, rej) => {\n      stream.on('data', chunk => {\n        dxfString += chunk;\n      });\n      stream.on('end', () => {\n        try {\n          res(self._parse(dxfString));\n        } catch (err) {\n          rej(err);\n        }\n      });\n      stream.on('error', err => {\n        rej(err);\n      });\n    });\n  }\n  _parse(dxfString) {\n    const dxf = {};\n    let lastHandle = 0;\n    const dxfLinesArray = dxfString.split(/\\r\\n|\\r|\\n/g);\n    const scanner = new DxfArrayScanner(dxfLinesArray);\n    if (!scanner.hasNext()) throw Error('Empty file');\n    const self = this;\n    let curr;\n    function parseAll() {\n      curr = scanner.next();\n      while (!scanner.isEOF()) {\n        if (curr.code === 0 && curr.value === 'SECTION') {\n          curr = scanner.next();\n          // Be sure we are reading a section code\n          if (curr.code !== 2) {\n            console.error('Unexpected code %s after 0:SECTION', debugCode(curr));\n            curr = scanner.next();\n            continue;\n          }\n          if (curr.value === 'HEADER') {\n            log.debug('> HEADER');\n            dxf.header = parseHeader();\n            log.debug('<');\n          } else if (curr.value === 'BLOCKS') {\n            log.debug('> BLOCKS');\n            dxf.blocks = parseBlocks();\n            log.debug('<');\n          } else if (curr.value === 'ENTITIES') {\n            log.debug('> ENTITIES');\n            dxf.entities = parseEntities(false);\n            log.debug('<');\n          } else if (curr.value === 'TABLES') {\n            log.debug('> TABLES');\n            dxf.tables = parseTables();\n            log.debug('<');\n          } else if (curr.value === 'EOF') {\n            log.debug('EOF');\n          } else {\n            log.warn('Skipping section \\'%s\\'', curr.value);\n          }\n        } else {\n          curr = scanner.next();\n        }\n        // If is a new section\n      }\n    }\n    /**\n     *\n     * @return {object} header\n     */\n    function parseHeader() {\n      // interesting variables:\n      //  $ACADVER, $VIEWDIR, $VIEWSIZE, $VIEWCTR, $TDCREATE, $TDUPDATE\n      // http://www.autodesk.com/techpubs/autocad/acadr14/dxf/header_section_al_u05_c.htm\n      // Also see VPORT table entries\n      let currVarName = null;\n      let currVarValue = null;\n      const header = {};\n      // loop through header variables\n      curr = scanner.next();\n      while (true) {\n        if (groupIs(curr, 0, 'ENDSEC')) {\n          if (currVarName) header[currVarName] = currVarValue;\n          break;\n        } else if (curr.code === 9) {\n          if (currVarName) header[currVarName] = currVarValue;\n          currVarName = curr.value;\n          // Filter here for particular variables we are interested in\n        } else {\n          if (curr.code === 10) {\n            currVarValue = {\n              x: curr.value\n            };\n          } else if (curr.code === 20) {\n            currVarValue.y = curr.value;\n          } else if (curr.code === 30) {\n            currVarValue.z = curr.value;\n          } else {\n            currVarValue = curr.value;\n          }\n        }\n        curr = scanner.next();\n      }\n      // console.log(util.inspect(header, { colors: true, depth: null }));\n      curr = scanner.next(); // swallow up ENDSEC\n      return header;\n    }\n    /**\n     *\n     */\n    function parseBlocks() {\n      const blocks = {};\n      curr = scanner.next();\n      while (curr.value !== 'EOF') {\n        if (groupIs(curr, 0, 'ENDSEC')) {\n          break;\n        }\n        if (groupIs(curr, 0, 'BLOCK')) {\n          log.debug('block {');\n          const block = parseBlock();\n          log.debug('}');\n          ensureHandle(block);\n          if (!block.name) log.error('block with handle \"' + block.handle + '\" is missing a name.');else blocks[block.name] = block;\n        } else {\n          logUnhandledGroup(curr);\n          curr = scanner.next();\n        }\n      }\n      return blocks;\n    }\n    function parseBlock() {\n      const block = {};\n      curr = scanner.next();\n      while (curr.value !== 'EOF') {\n        switch (curr.code) {\n          case 1:\n            block.xrefPath = curr.value;\n            curr = scanner.next();\n            break;\n          case 2:\n            block.name = curr.value;\n            curr = scanner.next();\n            break;\n          case 3:\n            block.name2 = curr.value;\n            curr = scanner.next();\n            break;\n          case 5:\n            block.handle = curr.value;\n            curr = scanner.next();\n            break;\n          case 8:\n            block.layer = curr.value;\n            curr = scanner.next();\n            break;\n          case 10:\n            block.position = parsePoint(curr);\n            curr = scanner.next();\n            break;\n          case 67:\n            block.paperSpace = curr.value && curr.value == 1 ? true : false;\n            curr = scanner.next();\n            break;\n          case 70:\n            if (curr.value != 0) {\n              //if(curr.value & BLOCK_ANONYMOUS_FLAG) console.log('  Anonymous block');\n              //if(curr.value & BLOCK_NON_CONSTANT_FLAG) console.log('  Non-constant attributes');\n              //if(curr.value & BLOCK_XREF_FLAG) console.log('  Is xref');\n              //if(curr.value & BLOCK_XREF_OVERLAY_FLAG) console.log('  Is xref overlay');\n              //if(curr.value & BLOCK_EXTERNALLY_DEPENDENT_FLAG) console.log('  Is externally dependent');\n              //if(curr.value & BLOCK_RESOLVED_OR_DEPENDENT_FLAG) console.log('  Is resolved xref or dependent of an xref');\n              //if(curr.value & BLOCK_REFERENCED_XREF) console.log('  This definition is a referenced xref');\n              block.type = curr.value;\n            }\n            curr = scanner.next();\n            break;\n          case 100:\n            // ignore class markers\n            curr = scanner.next();\n            break;\n          case 330:\n            block.ownerHandle = curr.value;\n            curr = scanner.next();\n            break;\n          case 0:\n            if (curr.value == 'ENDBLK') break;\n            block.entities = parseEntities(true);\n            break;\n          default:\n            logUnhandledGroup(curr);\n            curr = scanner.next();\n        }\n        if (groupIs(curr, 0, 'ENDBLK')) {\n          curr = scanner.next();\n          break;\n        }\n      }\n      return block;\n    }\n    /**\n     * parseTables\n     * @return {Object} Object representing tables\n     */\n    function parseTables() {\n      const tables = {};\n      curr = scanner.next();\n      while (curr.value !== 'EOF') {\n        if (groupIs(curr, 0, 'ENDSEC')) break;\n        if (groupIs(curr, 0, 'TABLE')) {\n          curr = scanner.next();\n          const tableDefinition = tableDefinitions[curr.value];\n          if (tableDefinition) {\n            log.debug(curr.value + ' Table {');\n            tables[tableDefinitions[curr.value].tableName] = parseTable(curr);\n            log.debug('}');\n          } else {\n            log.debug('Unhandled Table ' + curr.value);\n          }\n        } else {\n          // else ignored\n          curr = scanner.next();\n        }\n      }\n      curr = scanner.next();\n      return tables;\n    }\n    const END_OF_TABLE_VALUE = 'ENDTAB';\n    function parseTable(group) {\n      const tableDefinition = tableDefinitions[group.value];\n      const table = {};\n      let expectedCount = 0;\n      curr = scanner.next();\n      while (!groupIs(curr, 0, END_OF_TABLE_VALUE)) {\n        switch (curr.code) {\n          case 5:\n            table.handle = curr.value;\n            curr = scanner.next();\n            break;\n          case 330:\n            table.ownerHandle = curr.value;\n            curr = scanner.next();\n            break;\n          case 100:\n            if (curr.value === 'AcDbSymbolTable') {\n              // ignore\n              curr = scanner.next();\n            } else {\n              logUnhandledGroup(curr);\n              curr = scanner.next();\n            }\n            break;\n          case 70:\n            expectedCount = curr.value;\n            curr = scanner.next();\n            break;\n          case 0:\n            if (curr.value === tableDefinition.dxfSymbolName) {\n              table[tableDefinition.tableRecordsProperty] = tableDefinition.parseTableRecords();\n            } else {\n              logUnhandledGroup(curr);\n              curr = scanner.next();\n            }\n            break;\n          default:\n            logUnhandledGroup(curr);\n            curr = scanner.next();\n        }\n      }\n      const tableRecords = table[tableDefinition.tableRecordsProperty];\n      if (tableRecords) {\n        let actualCount = (() => {\n          if (tableRecords.constructor === Array) {\n            return tableRecords.length;\n          } else if (typeof tableRecords === 'object') {\n            return Object.keys(tableRecords).length;\n          }\n          return undefined;\n        })();\n        if (expectedCount !== actualCount) log.warn('Parsed ' + actualCount + ' ' + tableDefinition.dxfSymbolName + '\\'s but expected ' + expectedCount);\n      }\n      curr = scanner.next();\n      return table;\n    }\n    function parseViewPortRecords() {\n      const viewPorts = []; // Multiple table entries may have the same name indicating a multiple viewport configuration\n      let viewPort = {};\n      log.debug('ViewPort {');\n      curr = scanner.next();\n      while (!groupIs(curr, 0, END_OF_TABLE_VALUE)) {\n        switch (curr.code) {\n          case 2:\n            // layer name\n            viewPort.name = curr.value;\n            curr = scanner.next();\n            break;\n          case 10:\n            viewPort.lowerLeftCorner = parsePoint(curr);\n            curr = scanner.next();\n            break;\n          case 11:\n            viewPort.upperRightCorner = parsePoint(curr);\n            curr = scanner.next();\n            break;\n          case 12:\n            viewPort.center = parsePoint(curr);\n            curr = scanner.next();\n            break;\n          case 13:\n            viewPort.snapBasePoint = parsePoint(curr);\n            curr = scanner.next();\n            break;\n          case 14:\n            viewPort.snapSpacing = parsePoint(curr);\n            curr = scanner.next();\n            break;\n          case 15:\n            viewPort.gridSpacing = parsePoint(curr);\n            curr = scanner.next();\n            break;\n          case 16:\n            viewPort.viewDirectionFromTarget = parsePoint(curr);\n            curr = scanner.next();\n            break;\n          case 17:\n            viewPort.viewTarget = parsePoint(curr);\n            curr = scanner.next();\n            break;\n          case 42:\n            viewPort.lensLength = curr.value;\n            curr = scanner.next();\n            break;\n          case 43:\n            viewPort.frontClippingPlane = curr.value;\n            curr = scanner.next();\n            break;\n          case 44:\n            viewPort.backClippingPlane = curr.value;\n            curr = scanner.next();\n            break;\n          case 45:\n            viewPort.viewHeight = curr.value;\n            curr = scanner.next();\n            break;\n          case 50:\n            viewPort.snapRotationAngle = curr.value;\n            curr = scanner.next();\n            break;\n          case 51:\n            viewPort.viewTwistAngle = curr.value;\n            curr = scanner.next();\n            break;\n          case 79:\n            viewPort.orthographicType = curr.value;\n            curr = scanner.next();\n            break;\n          case 110:\n            viewPort.ucsOrigin = parsePoint(curr);\n            curr = scanner.next();\n            break;\n          case 111:\n            viewPort.ucsXAxis = parsePoint(curr);\n            curr = scanner.next();\n            break;\n          case 112:\n            viewPort.ucsYAxis = parsePoint(curr);\n            curr = scanner.next();\n            break;\n          case 110:\n            viewPort.ucsOrigin = parsePoint(curr);\n            curr = scanner.next();\n            break;\n          case 281:\n            viewPort.renderMode = curr.value;\n            curr = scanner.next();\n            break;\n          case 281:\n            // 0 is one distant light, 1 is two distant lights\n            viewPort.defaultLightingType = curr.value;\n            curr = scanner.next();\n            break;\n          case 292:\n            viewPort.defaultLightingOn = curr.value;\n            curr = scanner.next();\n            break;\n          case 330:\n            viewPort.ownerHandle = curr.value;\n            curr = scanner.next();\n            break;\n          case 63: // These are all ambient color. Perhaps should be a gradient when multiple are set.\n          case 421:\n          case 431:\n            viewPort.ambientColor = curr.value;\n            curr = scanner.next();\n            break;\n          case 0:\n            // New ViewPort\n            if (curr.value === 'VPORT') {\n              log.debug('}');\n              viewPorts.push(viewPort);\n              log.debug('ViewPort {');\n              viewPort = {};\n              curr = scanner.next();\n            }\n            break;\n          default:\n            logUnhandledGroup(curr);\n            curr = scanner.next();\n            break;\n        }\n      }\n      // Note: do not call scanner.next() here,\n      //  parseTable() needs the current group\n      log.debug('}');\n      viewPorts.push(viewPort);\n      return viewPorts;\n    }\n    function parseLineTypes() {\n      const ltypes = {};\n      let ltype = {};\n      let length = 0;\n      let ltypeName;\n      log.debug('LType {');\n      curr = scanner.next();\n      while (!groupIs(curr, 0, 'ENDTAB')) {\n        switch (curr.code) {\n          case 2:\n            ltype.name = curr.value;\n            ltypeName = curr.value;\n            curr = scanner.next();\n            break;\n          case 3:\n            ltype.description = curr.value;\n            curr = scanner.next();\n            break;\n          case 73:\n            // Number of elements for this line type (dots, dashes, spaces);\n            length = curr.value;\n            if (length > 0) ltype.pattern = [];\n            curr = scanner.next();\n            break;\n          case 40:\n            // total pattern length\n            ltype.patternLength = curr.value;\n            curr = scanner.next();\n            break;\n          case 49:\n            ltype.pattern.push(curr.value);\n            curr = scanner.next();\n            break;\n          case 0:\n            log.debug('}');\n            if (length > 0 && length !== ltype.pattern.length) log.warn('lengths do not match on LTYPE pattern');\n            ltypes[ltypeName] = ltype;\n            ltype = {};\n            log.debug('LType {');\n            curr = scanner.next();\n            break;\n          default:\n            curr = scanner.next();\n        }\n      }\n      log.debug('}');\n      ltypes[ltypeName] = ltype;\n      return ltypes;\n    }\n    function parseLayers() {\n      const layers = {};\n      let layer = {};\n      let layerName;\n      log.debug('Layer {');\n      curr = scanner.next();\n      while (!groupIs(curr, 0, 'ENDTAB')) {\n        switch (curr.code) {\n          case 2:\n            // layer name\n            layer.name = curr.value;\n            layerName = curr.value;\n            curr = scanner.next();\n            break;\n          case 62:\n            // color, visibility\n            layer.visible = curr.value >= 0;\n            // TODO 0 and 256 are BYBLOCK and BYLAYER respectively. Need to handle these values for layers?.\n            layer.colorIndex = Math.abs(curr.value);\n            layer.color = getAcadColor(layer.colorIndex);\n            curr = scanner.next();\n            break;\n          case 70:\n            // frozen layer\n            layer.frozen = (curr.value & 1) != 0 || (curr.value & 2) != 0;\n            curr = scanner.next();\n            break;\n          case 0:\n            // New Layer\n            if (curr.value === 'LAYER') {\n              log.debug('}');\n              layers[layerName] = layer;\n              log.debug('Layer {');\n              layer = {};\n              layerName = undefined;\n              curr = scanner.next();\n            }\n            break;\n          default:\n            logUnhandledGroup(curr);\n            curr = scanner.next();\n            break;\n        }\n      }\n      // Note: do not call scanner.next() here,\n      //  parseLayerTable() needs the current group\n      log.debug('}');\n      layers[layerName] = layer;\n      return layers;\n    }\n    const tableDefinitions = {\n      VPORT: {\n        tableRecordsProperty: 'viewPorts',\n        tableName: 'viewPort',\n        dxfSymbolName: 'VPORT',\n        parseTableRecords: parseViewPortRecords\n      },\n      LTYPE: {\n        tableRecordsProperty: 'lineTypes',\n        tableName: 'lineType',\n        dxfSymbolName: 'LTYPE',\n        parseTableRecords: parseLineTypes\n      },\n      LAYER: {\n        tableRecordsProperty: 'layers',\n        tableName: 'layer',\n        dxfSymbolName: 'LAYER',\n        parseTableRecords: parseLayers\n      }\n    };\n    /**\n     * Is called after the parser first reads the 0:ENTITIES group. The scanner\n     * should be on the start of the first entity already.\n     * @return {Array} the resulting entities\n     */\n    function parseEntities(forBlock) {\n      const entities = [];\n      const endingOnValue = forBlock ? 'ENDBLK' : 'ENDSEC';\n      if (!forBlock) {\n        curr = scanner.next();\n      }\n      while (true) {\n        if (curr.code === 0) {\n          if (curr.value === endingOnValue) {\n            break;\n          }\n          const handler = self._entityHandlers[curr.value];\n          if (handler != null) {\n            log.debug(curr.value + ' {');\n            const entity = handler.parseEntity(scanner, curr);\n            curr = scanner.lastReadGroup;\n            log.debug('}');\n            ensureHandle(entity);\n            entities.push(entity);\n          } else {\n            log.warn('Unhandled entity ' + curr.value);\n            curr = scanner.next();\n            continue;\n          }\n        } else {\n          // ignored lines from unsupported entity\n          curr = scanner.next();\n        }\n      }\n      if (endingOnValue == 'ENDSEC') curr = scanner.next(); // swallow up ENDSEC, but not ENDBLK\n      return entities;\n    }\n    /**\n     * Parses a 2D or 3D point, returning it as an object with x, y, and\n     * (sometimes) z property if it is 3D. It is assumed the current group\n     * is x of the point being read in, and scanner.next() will return the\n     * y. The parser will determine if there is a z point automatically.\n     * @return {Object} The 2D or 3D point as an object with x, y[, z]\n     */\n    function parsePoint(curr) {\n      const point = {};\n      let code = curr.code;\n      point.x = curr.value;\n      code += 10;\n      curr = scanner.next();\n      if (curr.code != code) throw new Error('Expected code for point value to be ' + code + ' but got ' + curr.code + '.');\n      point.y = curr.value;\n      code += 10;\n      curr = scanner.next();\n      if (curr.code != code) {\n        scanner.rewind();\n        return point;\n      }\n      point.z = curr.value;\n      return point;\n    }\n    function ensureHandle(entity) {\n      if (!entity) throw new TypeError('entity cannot be undefined or null');\n      if (!entity.handle) entity.handle = lastHandle++;\n    }\n    parseAll();\n    return dxf;\n  }\n}\nfunction groupIs(group, code, value) {\n  return group.code === code && group.value === value;\n}\nfunction logUnhandledGroup(curr) {\n  log.debug('unhandled group ' + debugCode(curr));\n}\nfunction debugCode(curr) {\n  return curr.code + ':' + curr.value;\n}\n/**\n * Returns the truecolor value of the given AutoCad color index value\n * @return {Number} truecolor value as a number\n */\nfunction getAcadColor(index) {\n  return AUTO_CAD_COLOR_INDEX[index];\n}\n// const BLOCK_ANONYMOUS_FLAG = 1;\n// const BLOCK_NON_CONSTANT_FLAG = 2;\n// const BLOCK_XREF_FLAG = 4;\n// const BLOCK_XREF_OVERLAY_FLAG = 8;\n// const BLOCK_EXTERNALLY_DEPENDENT_FLAG = 16;\n// const BLOCK_RESOLVED_OR_DEPENDENT_FLAG = 32;\n// const BLOCK_REFERENCED_XREF = 64;\n/* Notes */\n// Code 6 of an entity indicates inheritance of properties (eg. color).\n//   BYBLOCK means inherits from block\n//   BYLAYER (default) mean inherits from layer","map":{"version":3,"names":["DxfArrayScanner","AUTO_CAD_COLOR_INDEX","Face","Arc","AttDef","Circle","Dimension","Ellipse","Insert","Line","LWPolyline","MText","Point","Polyline","Solid","Spline","Text","log","setLevel","registerDefaultEntityHandlers","dxfParser","registerEntityHandler","DxfParser","constructor","_entityHandlers","parse","source","_parse","console","error","handlerType","instance","ForEntityName","parseSync","parseStream","stream","dxfString","self","Promise","res","rej","on","chunk","err","dxf","lastHandle","dxfLinesArray","split","scanner","hasNext","Error","curr","parseAll","next","isEOF","code","value","debugCode","debug","header","parseHeader","blocks","parseBlocks","entities","parseEntities","tables","parseTables","warn","currVarName","currVarValue","groupIs","x","y","z","block","parseBlock","ensureHandle","name","handle","logUnhandledGroup","xrefPath","name2","layer","position","parsePoint","paperSpace","type","ownerHandle","tableDefinition","tableDefinitions","tableName","parseTable","END_OF_TABLE_VALUE","group","table","expectedCount","dxfSymbolName","tableRecordsProperty","parseTableRecords","tableRecords","actualCount","Array","length","Object","keys","undefined","parseViewPortRecords","viewPorts","viewPort","lowerLeftCorner","upperRightCorner","center","snapBasePoint","snapSpacing","gridSpacing","viewDirectionFromTarget","viewTarget","lensLength","frontClippingPlane","backClippingPlane","viewHeight","snapRotationAngle","viewTwistAngle","orthographicType","ucsOrigin","ucsXAxis","ucsYAxis","renderMode","defaultLightingType","defaultLightingOn","ambientColor","push","parseLineTypes","ltypes","ltype","ltypeName","description","pattern","patternLength","parseLayers","layers","layerName","visible","colorIndex","Math","abs","color","getAcadColor","frozen","VPORT","LTYPE","LAYER","forBlock","endingOnValue","handler","entity","parseEntity","lastReadGroup","point","rewind","TypeError","index"],"sources":["C:/Users/chenx/Documents/sda/prototype/client/node_modules/dxf-parser/dist/DxfParser.js"],"sourcesContent":["import DxfArrayScanner from './DxfArrayScanner';\nimport AUTO_CAD_COLOR_INDEX from './AutoCadColorIndex';\nimport Face from './entities/3dface';\nimport Arc from './entities/arc';\nimport AttDef from './entities/attdef';\nimport Circle from './entities/circle';\nimport Dimension from './entities/dimension';\nimport Ellipse from './entities/ellipse';\nimport Insert from './entities/insert';\nimport Line from './entities/line';\nimport LWPolyline from './entities/lwpolyline';\nimport MText from './entities/mtext';\nimport Point from './entities/point';\nimport Polyline from './entities/polyline';\nimport Solid from './entities/solid';\nimport Spline from './entities/spline';\nimport Text from './entities/text';\n//import Vertex from './entities/';\nimport log from 'loglevel';\n//log.setLevel('trace');\n//log.setLevel('debug');\n//log.setLevel('info');\n//log.setLevel('warn');\nlog.setLevel('error');\nfunction registerDefaultEntityHandlers(dxfParser) {\n    // Supported entities here (some entity code is still being refactored into this flow)\n    dxfParser.registerEntityHandler(Face);\n    dxfParser.registerEntityHandler(Arc);\n    dxfParser.registerEntityHandler(AttDef);\n    dxfParser.registerEntityHandler(Circle);\n    dxfParser.registerEntityHandler(Dimension);\n    dxfParser.registerEntityHandler(Ellipse);\n    dxfParser.registerEntityHandler(Insert);\n    dxfParser.registerEntityHandler(Line);\n    dxfParser.registerEntityHandler(LWPolyline);\n    dxfParser.registerEntityHandler(MText);\n    dxfParser.registerEntityHandler(Point);\n    dxfParser.registerEntityHandler(Polyline);\n    dxfParser.registerEntityHandler(Solid);\n    dxfParser.registerEntityHandler(Spline);\n    dxfParser.registerEntityHandler(Text);\n    //dxfParser.registerEntityHandler(require('./entities/vertex'));\n}\nexport default class DxfParser {\n    constructor() {\n        this._entityHandlers = {};\n        registerDefaultEntityHandlers(this);\n    }\n    parse(source) {\n        if (typeof source === 'string') {\n            return this._parse(source);\n        }\n        else {\n            console.error('Cannot read dxf source of type `' + typeof (source));\n            return null;\n        }\n    }\n    registerEntityHandler(handlerType) {\n        const instance = new handlerType();\n        this._entityHandlers[instance.ForEntityName] = instance;\n    }\n    parseSync(source) {\n        return this.parse(source);\n    }\n    parseStream(stream) {\n        let dxfString = \"\";\n        const self = this;\n        return new Promise((res, rej) => {\n            stream.on('data', (chunk) => {\n                dxfString += chunk;\n            });\n            stream.on('end', () => {\n                try {\n                    res(self._parse(dxfString));\n                }\n                catch (err) {\n                    rej(err);\n                }\n            });\n            stream.on('error', (err) => {\n                rej(err);\n            });\n        });\n    }\n    _parse(dxfString) {\n        const dxf = {};\n        let lastHandle = 0;\n        const dxfLinesArray = dxfString.split(/\\r\\n|\\r|\\n/g);\n        const scanner = new DxfArrayScanner(dxfLinesArray);\n        if (!scanner.hasNext())\n            throw Error('Empty file');\n        const self = this;\n        let curr;\n        function parseAll() {\n            curr = scanner.next();\n            while (!scanner.isEOF()) {\n                if (curr.code === 0 && curr.value === 'SECTION') {\n                    curr = scanner.next();\n                    // Be sure we are reading a section code\n                    if (curr.code !== 2) {\n                        console.error('Unexpected code %s after 0:SECTION', debugCode(curr));\n                        curr = scanner.next();\n                        continue;\n                    }\n                    if (curr.value === 'HEADER') {\n                        log.debug('> HEADER');\n                        dxf.header = parseHeader();\n                        log.debug('<');\n                    }\n                    else if (curr.value === 'BLOCKS') {\n                        log.debug('> BLOCKS');\n                        dxf.blocks = parseBlocks();\n                        log.debug('<');\n                    }\n                    else if (curr.value === 'ENTITIES') {\n                        log.debug('> ENTITIES');\n                        dxf.entities = parseEntities(false);\n                        log.debug('<');\n                    }\n                    else if (curr.value === 'TABLES') {\n                        log.debug('> TABLES');\n                        dxf.tables = parseTables();\n                        log.debug('<');\n                    }\n                    else if (curr.value === 'EOF') {\n                        log.debug('EOF');\n                    }\n                    else {\n                        log.warn('Skipping section \\'%s\\'', curr.value);\n                    }\n                }\n                else {\n                    curr = scanner.next();\n                }\n                // If is a new section\n            }\n        }\n        /**\n         *\n         * @return {object} header\n         */\n        function parseHeader() {\n            // interesting variables:\n            //  $ACADVER, $VIEWDIR, $VIEWSIZE, $VIEWCTR, $TDCREATE, $TDUPDATE\n            // http://www.autodesk.com/techpubs/autocad/acadr14/dxf/header_section_al_u05_c.htm\n            // Also see VPORT table entries\n            let currVarName = null;\n            let currVarValue = null;\n            const header = {};\n            // loop through header variables\n            curr = scanner.next();\n            while (true) {\n                if (groupIs(curr, 0, 'ENDSEC')) {\n                    if (currVarName)\n                        header[currVarName] = currVarValue;\n                    break;\n                }\n                else if (curr.code === 9) {\n                    if (currVarName)\n                        header[currVarName] = currVarValue;\n                    currVarName = curr.value;\n                    // Filter here for particular variables we are interested in\n                }\n                else {\n                    if (curr.code === 10) {\n                        currVarValue = { x: curr.value };\n                    }\n                    else if (curr.code === 20) {\n                        currVarValue.y = curr.value;\n                    }\n                    else if (curr.code === 30) {\n                        currVarValue.z = curr.value;\n                    }\n                    else {\n                        currVarValue = curr.value;\n                    }\n                }\n                curr = scanner.next();\n            }\n            // console.log(util.inspect(header, { colors: true, depth: null }));\n            curr = scanner.next(); // swallow up ENDSEC\n            return header;\n        }\n        /**\n         *\n         */\n        function parseBlocks() {\n            const blocks = {};\n            curr = scanner.next();\n            while (curr.value !== 'EOF') {\n                if (groupIs(curr, 0, 'ENDSEC')) {\n                    break;\n                }\n                if (groupIs(curr, 0, 'BLOCK')) {\n                    log.debug('block {');\n                    const block = parseBlock();\n                    log.debug('}');\n                    ensureHandle(block);\n                    if (!block.name)\n                        log.error('block with handle \"' + block.handle + '\" is missing a name.');\n                    else\n                        blocks[block.name] = block;\n                }\n                else {\n                    logUnhandledGroup(curr);\n                    curr = scanner.next();\n                }\n            }\n            return blocks;\n        }\n        function parseBlock() {\n            const block = {};\n            curr = scanner.next();\n            while (curr.value !== 'EOF') {\n                switch (curr.code) {\n                    case 1:\n                        block.xrefPath = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 2:\n                        block.name = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 3:\n                        block.name2 = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 5:\n                        block.handle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 8:\n                        block.layer = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 10:\n                        block.position = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 67:\n                        block.paperSpace = (curr.value && curr.value == 1) ? true : false;\n                        curr = scanner.next();\n                        break;\n                    case 70:\n                        if (curr.value != 0) {\n                            //if(curr.value & BLOCK_ANONYMOUS_FLAG) console.log('  Anonymous block');\n                            //if(curr.value & BLOCK_NON_CONSTANT_FLAG) console.log('  Non-constant attributes');\n                            //if(curr.value & BLOCK_XREF_FLAG) console.log('  Is xref');\n                            //if(curr.value & BLOCK_XREF_OVERLAY_FLAG) console.log('  Is xref overlay');\n                            //if(curr.value & BLOCK_EXTERNALLY_DEPENDENT_FLAG) console.log('  Is externally dependent');\n                            //if(curr.value & BLOCK_RESOLVED_OR_DEPENDENT_FLAG) console.log('  Is resolved xref or dependent of an xref');\n                            //if(curr.value & BLOCK_REFERENCED_XREF) console.log('  This definition is a referenced xref');\n                            block.type = curr.value;\n                        }\n                        curr = scanner.next();\n                        break;\n                    case 100:\n                        // ignore class markers\n                        curr = scanner.next();\n                        break;\n                    case 330:\n                        block.ownerHandle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 0:\n                        if (curr.value == 'ENDBLK')\n                            break;\n                        block.entities = parseEntities(true);\n                        break;\n                    default:\n                        logUnhandledGroup(curr);\n                        curr = scanner.next();\n                }\n                if (groupIs(curr, 0, 'ENDBLK')) {\n                    curr = scanner.next();\n                    break;\n                }\n            }\n            return block;\n        }\n        /**\n         * parseTables\n         * @return {Object} Object representing tables\n         */\n        function parseTables() {\n            const tables = {};\n            curr = scanner.next();\n            while (curr.value !== 'EOF') {\n                if (groupIs(curr, 0, 'ENDSEC'))\n                    break;\n                if (groupIs(curr, 0, 'TABLE')) {\n                    curr = scanner.next();\n                    const tableDefinition = tableDefinitions[curr.value];\n                    if (tableDefinition) {\n                        log.debug(curr.value + ' Table {');\n                        tables[tableDefinitions[curr.value].tableName] = parseTable(curr);\n                        log.debug('}');\n                    }\n                    else {\n                        log.debug('Unhandled Table ' + curr.value);\n                    }\n                }\n                else {\n                    // else ignored\n                    curr = scanner.next();\n                }\n            }\n            curr = scanner.next();\n            return tables;\n        }\n        const END_OF_TABLE_VALUE = 'ENDTAB';\n        function parseTable(group) {\n            const tableDefinition = tableDefinitions[group.value];\n            const table = {};\n            let expectedCount = 0;\n            curr = scanner.next();\n            while (!groupIs(curr, 0, END_OF_TABLE_VALUE)) {\n                switch (curr.code) {\n                    case 5:\n                        table.handle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 330:\n                        table.ownerHandle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 100:\n                        if (curr.value === 'AcDbSymbolTable') {\n                            // ignore\n                            curr = scanner.next();\n                        }\n                        else {\n                            logUnhandledGroup(curr);\n                            curr = scanner.next();\n                        }\n                        break;\n                    case 70:\n                        expectedCount = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 0:\n                        if (curr.value === tableDefinition.dxfSymbolName) {\n                            table[tableDefinition.tableRecordsProperty] = tableDefinition.parseTableRecords();\n                        }\n                        else {\n                            logUnhandledGroup(curr);\n                            curr = scanner.next();\n                        }\n                        break;\n                    default:\n                        logUnhandledGroup(curr);\n                        curr = scanner.next();\n                }\n            }\n            const tableRecords = table[tableDefinition.tableRecordsProperty];\n            if (tableRecords) {\n                let actualCount = (() => {\n                    if (tableRecords.constructor === Array) {\n                        return tableRecords.length;\n                    }\n                    else if (typeof (tableRecords) === 'object') {\n                        return Object.keys(tableRecords).length;\n                    }\n                    return undefined;\n                })();\n                if (expectedCount !== actualCount)\n                    log.warn('Parsed ' + actualCount + ' ' + tableDefinition.dxfSymbolName + '\\'s but expected ' + expectedCount);\n            }\n            curr = scanner.next();\n            return table;\n        }\n        function parseViewPortRecords() {\n            const viewPorts = []; // Multiple table entries may have the same name indicating a multiple viewport configuration\n            let viewPort = {};\n            log.debug('ViewPort {');\n            curr = scanner.next();\n            while (!groupIs(curr, 0, END_OF_TABLE_VALUE)) {\n                switch (curr.code) {\n                    case 2: // layer name\n                        viewPort.name = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 10:\n                        viewPort.lowerLeftCorner = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 11:\n                        viewPort.upperRightCorner = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 12:\n                        viewPort.center = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 13:\n                        viewPort.snapBasePoint = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 14:\n                        viewPort.snapSpacing = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 15:\n                        viewPort.gridSpacing = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 16:\n                        viewPort.viewDirectionFromTarget = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 17:\n                        viewPort.viewTarget = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 42:\n                        viewPort.lensLength = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 43:\n                        viewPort.frontClippingPlane = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 44:\n                        viewPort.backClippingPlane = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 45:\n                        viewPort.viewHeight = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 50:\n                        viewPort.snapRotationAngle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 51:\n                        viewPort.viewTwistAngle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 79:\n                        viewPort.orthographicType = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 110:\n                        viewPort.ucsOrigin = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 111:\n                        viewPort.ucsXAxis = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 112:\n                        viewPort.ucsYAxis = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 110:\n                        viewPort.ucsOrigin = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 281:\n                        viewPort.renderMode = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 281:\n                        // 0 is one distant light, 1 is two distant lights\n                        viewPort.defaultLightingType = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 292:\n                        viewPort.defaultLightingOn = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 330:\n                        viewPort.ownerHandle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 63: // These are all ambient color. Perhaps should be a gradient when multiple are set.\n                    case 421:\n                    case 431:\n                        viewPort.ambientColor = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 0:\n                        // New ViewPort\n                        if (curr.value === 'VPORT') {\n                            log.debug('}');\n                            viewPorts.push(viewPort);\n                            log.debug('ViewPort {');\n                            viewPort = {};\n                            curr = scanner.next();\n                        }\n                        break;\n                    default:\n                        logUnhandledGroup(curr);\n                        curr = scanner.next();\n                        break;\n                }\n            }\n            // Note: do not call scanner.next() here,\n            //  parseTable() needs the current group\n            log.debug('}');\n            viewPorts.push(viewPort);\n            return viewPorts;\n        }\n        function parseLineTypes() {\n            const ltypes = {};\n            let ltype = {};\n            let length = 0;\n            let ltypeName;\n            log.debug('LType {');\n            curr = scanner.next();\n            while (!groupIs(curr, 0, 'ENDTAB')) {\n                switch (curr.code) {\n                    case 2:\n                        ltype.name = curr.value;\n                        ltypeName = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 3:\n                        ltype.description = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 73: // Number of elements for this line type (dots, dashes, spaces);\n                        length = curr.value;\n                        if (length > 0)\n                            ltype.pattern = [];\n                        curr = scanner.next();\n                        break;\n                    case 40: // total pattern length\n                        ltype.patternLength = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 49:\n                        ltype.pattern.push(curr.value);\n                        curr = scanner.next();\n                        break;\n                    case 0:\n                        log.debug('}');\n                        if (length > 0 && length !== ltype.pattern.length)\n                            log.warn('lengths do not match on LTYPE pattern');\n                        ltypes[ltypeName] = ltype;\n                        ltype = {};\n                        log.debug('LType {');\n                        curr = scanner.next();\n                        break;\n                    default:\n                        curr = scanner.next();\n                }\n            }\n            log.debug('}');\n            ltypes[ltypeName] = ltype;\n            return ltypes;\n        }\n        function parseLayers() {\n            const layers = {};\n            let layer = {};\n            let layerName;\n            log.debug('Layer {');\n            curr = scanner.next();\n            while (!groupIs(curr, 0, 'ENDTAB')) {\n                switch (curr.code) {\n                    case 2: // layer name\n                        layer.name = curr.value;\n                        layerName = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 62: // color, visibility\n                        layer.visible = curr.value >= 0;\n                        // TODO 0 and 256 are BYBLOCK and BYLAYER respectively. Need to handle these values for layers?.\n                        layer.colorIndex = Math.abs(curr.value);\n                        layer.color = getAcadColor(layer.colorIndex);\n                        curr = scanner.next();\n                        break;\n                    case 70: // frozen layer\n                        layer.frozen = ((curr.value & 1) != 0 || (curr.value & 2) != 0);\n                        curr = scanner.next();\n                        break;\n                    case 0:\n                        // New Layer\n                        if (curr.value === 'LAYER') {\n                            log.debug('}');\n                            layers[layerName] = layer;\n                            log.debug('Layer {');\n                            layer = {};\n                            layerName = undefined;\n                            curr = scanner.next();\n                        }\n                        break;\n                    default:\n                        logUnhandledGroup(curr);\n                        curr = scanner.next();\n                        break;\n                }\n            }\n            // Note: do not call scanner.next() here,\n            //  parseLayerTable() needs the current group\n            log.debug('}');\n            layers[layerName] = layer;\n            return layers;\n        }\n        const tableDefinitions = {\n            VPORT: {\n                tableRecordsProperty: 'viewPorts',\n                tableName: 'viewPort',\n                dxfSymbolName: 'VPORT',\n                parseTableRecords: parseViewPortRecords\n            },\n            LTYPE: {\n                tableRecordsProperty: 'lineTypes',\n                tableName: 'lineType',\n                dxfSymbolName: 'LTYPE',\n                parseTableRecords: parseLineTypes\n            },\n            LAYER: {\n                tableRecordsProperty: 'layers',\n                tableName: 'layer',\n                dxfSymbolName: 'LAYER',\n                parseTableRecords: parseLayers\n            }\n        };\n        /**\n         * Is called after the parser first reads the 0:ENTITIES group. The scanner\n         * should be on the start of the first entity already.\n         * @return {Array} the resulting entities\n         */\n        function parseEntities(forBlock) {\n            const entities = [];\n            const endingOnValue = forBlock ? 'ENDBLK' : 'ENDSEC';\n            if (!forBlock) {\n                curr = scanner.next();\n            }\n            while (true) {\n                if (curr.code === 0) {\n                    if (curr.value === endingOnValue) {\n                        break;\n                    }\n                    const handler = self._entityHandlers[curr.value];\n                    if (handler != null) {\n                        log.debug(curr.value + ' {');\n                        const entity = handler.parseEntity(scanner, curr);\n                        curr = scanner.lastReadGroup;\n                        log.debug('}');\n                        ensureHandle(entity);\n                        entities.push(entity);\n                    }\n                    else {\n                        log.warn('Unhandled entity ' + curr.value);\n                        curr = scanner.next();\n                        continue;\n                    }\n                }\n                else {\n                    // ignored lines from unsupported entity\n                    curr = scanner.next();\n                }\n            }\n            if (endingOnValue == 'ENDSEC')\n                curr = scanner.next(); // swallow up ENDSEC, but not ENDBLK\n            return entities;\n        }\n        /**\n         * Parses a 2D or 3D point, returning it as an object with x, y, and\n         * (sometimes) z property if it is 3D. It is assumed the current group\n         * is x of the point being read in, and scanner.next() will return the\n         * y. The parser will determine if there is a z point automatically.\n         * @return {Object} The 2D or 3D point as an object with x, y[, z]\n         */\n        function parsePoint(curr) {\n            const point = {};\n            let code = curr.code;\n            point.x = curr.value;\n            code += 10;\n            curr = scanner.next();\n            if (curr.code != code)\n                throw new Error('Expected code for point value to be ' + code +\n                    ' but got ' + curr.code + '.');\n            point.y = curr.value;\n            code += 10;\n            curr = scanner.next();\n            if (curr.code != code) {\n                scanner.rewind();\n                return point;\n            }\n            point.z = curr.value;\n            return point;\n        }\n        function ensureHandle(entity) {\n            if (!entity)\n                throw new TypeError('entity cannot be undefined or null');\n            if (!entity.handle)\n                entity.handle = lastHandle++;\n        }\n        parseAll();\n        return dxf;\n    }\n}\nfunction groupIs(group, code, value) {\n    return group.code === code && group.value === value;\n}\nfunction logUnhandledGroup(curr) {\n    log.debug('unhandled group ' + debugCode(curr));\n}\nfunction debugCode(curr) {\n    return curr.code + ':' + curr.value;\n}\n/**\n * Returns the truecolor value of the given AutoCad color index value\n * @return {Number} truecolor value as a number\n */\nfunction getAcadColor(index) {\n    return AUTO_CAD_COLOR_INDEX[index];\n}\n// const BLOCK_ANONYMOUS_FLAG = 1;\n// const BLOCK_NON_CONSTANT_FLAG = 2;\n// const BLOCK_XREF_FLAG = 4;\n// const BLOCK_XREF_OVERLAY_FLAG = 8;\n// const BLOCK_EXTERNALLY_DEPENDENT_FLAG = 16;\n// const BLOCK_RESOLVED_OR_DEPENDENT_FLAG = 32;\n// const BLOCK_REFERENCED_XREF = 64;\n/* Notes */\n// Code 6 of an entity indicates inheritance of properties (eg. color).\n//   BYBLOCK means inherits from block\n//   BYLAYER (default) mean inherits from layer\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}