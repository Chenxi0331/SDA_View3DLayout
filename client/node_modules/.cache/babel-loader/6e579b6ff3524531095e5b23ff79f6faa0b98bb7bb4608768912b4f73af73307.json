{"ast":null,"code":"/**\r\n * 3D Real Estate Management System - Prototype Pattern Implementation\r\n * Definition of Prototype Interface and Entities\r\n */\n\nimport * as THREE from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\nimport * as SkeletonUtils from 'three/examples/jsm/utils/SkeletonUtils';\n\n/**\r\n * Interface Component acting as the Prototype\r\n * All entities must implement a clone() method.\r\n */\n\nclass Wall {\n  constructor(width, height, depth) {\n    this.width = width;\n    this.height = height;\n    this.depth = depth;\n\n    // Create textured/colored wall\n    const geometry = new THREE.BoxGeometry(width, height, depth);\n    const material = new THREE.MeshStandardMaterial({\n      color: 0xf5f5f5,\n      // Off-white\n      roughness: 0.8,\n      side: THREE.DoubleSide\n    });\n    this.mesh = new THREE.Mesh(geometry, material);\n    this.mesh.castShadow = true;\n    this.mesh.receiveShadow = true;\n    this.mesh.userData = {\n      entityId: this.generateId(),\n      type: 'Wall'\n    };\n  }\n  generateId() {\n    return Math.random().toString(36).substr(2, 9);\n  }\n  setPosition(x, y, z) {\n    this.mesh.position.set(x, y, z);\n  }\n  clone() {\n    const clonedWall = new Wall(this.width, this.height, this.depth);\n    clonedWall.mesh.position.copy(this.mesh.position);\n    clonedWall.mesh.rotation.copy(this.mesh.rotation);\n    clonedWall.mesh.userData.entityId = this.generateId();\n    return clonedWall;\n  }\n}\nclass Furniture {\n  constructor(name, type, modelUrl = null) {\n    this.name = name;\n    this.type = type;\n    this.modelUrl = modelUrl;\n\n    // Default Mesh (Box) until model is loaded\n    this.mesh = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), new THREE.MeshStandardMaterial({\n      color: 0x888888\n    }));\n    this.mesh.castShadow = true;\n    this.mesh.receiveShadow = true;\n    this.mesh.userData = {\n      entityId: this.generateId(),\n      type: 'Furniture',\n      name: name\n    };\n    this.root = new THREE.Group();\n    this.root.add(this.mesh); // Add placeholder initially\n    this.root.userData = {\n      entityId: this.generateId(),\n      type: 'Furniture',\n      name: name\n    };\n  }\n  generateId() {\n    return Math.random().toString(36).substr(2, 9);\n  }\n  setPosition(x, y, z) {\n    this.root.position.set(x, y, z);\n  }\n  setScale(x, y, z) {\n    this.root.scale.set(x, y, z);\n  }\n  setRotation(x, y, z) {\n    this.root.rotation.set(x, y, z);\n  }\n\n  /**\r\n   * Async Load Model\r\n   */\n  async loadModel(loader) {\n    if (!this.modelUrl) return;\n    try {\n      const gltf = await loader.loadAsync(this.modelUrl);\n      const model = gltf.scene;\n\n      // Enable shadows\n      model.traverse(node => {\n        if (node.isMesh) {\n          node.castShadow = true;\n          node.receiveShadow = true;\n        }\n      });\n\n      // --- NORMALIZATION START ---\n      // Auto-Center and normalize scale to fit in a 1x1x1 box roughly, then apply this.scale.\n      // This prevents giant models from \"exploding\" the view.\n\n      const box = new THREE.Box3().setFromObject(model);\n      const size = new THREE.Vector3();\n      box.getSize(size);\n      const center = new THREE.Vector3();\n      box.getCenter(center);\n\n      // Center the model geometry\n      model.position.sub(center);\n      // Important: we shift the internal model, so the parent 'root' position is still valid.\n\n      // Optional: Auto-scale if model is huge or tiny\n      // Let's normalize it so the largest dimension is approx 1 unit, \n      // then we rely on this.root.scale to size it up to real-world meters.\n      // However, our JSON scale is roughly \"meters\" if the base is 1.\n      // Most GLTF models are in meters, but some are millimeters or arbitrary.\n\n      // Heuristic: If largest dim > 10, it's probably wrong scale (mm), or huge building.\n      // If < 0.1, it's probably too small.\n      // For safety in this demo, let's normalize base to max dim = 1.\n\n      const maxDim = Math.max(size.x, size.y, size.z);\n      if (maxDim > 0) {\n        const scaleFactor = 1.0 / maxDim;\n        model.scale.multiplyScalar(scaleFactor);\n      }\n\n      // --- NORMALIZATION END ---\n\n      // Replace placeholder with real model\n      this.root.remove(this.mesh);\n      this.root.add(model);\n      this.mesh = model;\n      console.log(`Loaded and normalized model for ${this.name}`);\n    } catch (err) {\n      console.error(`Failed to load model for ${this.name}`, err);\n    }\n  }\n\n  /**\r\n   * Factory method to create instance from JSON data\r\n   */\n  static fromJSON(data) {\n    const furniture = new Furniture(data.name, data.type, data.modelUrl);\n    if (data.position) furniture.setPosition(data.position.x, data.position.y, data.position.z);\n    if (data.rotation) furniture.setRotation(data.rotation.x, data.rotation.y, data.rotation.z);\n    if (data.scale) furniture.setScale(data.scale.x, data.scale.y, data.scale.z);\n    return furniture;\n  }\n\n  /**\r\n   * Deep Clone\r\n   */\n  clone() {\n    // Create new instance with same metadata\n    const clonedFurniture = new Furniture(this.name, this.type, this.modelUrl);\n\n    // Deep Clone the visual root using SkeletonUtils for GLTF support\n    const clonedRoot = SkeletonUtils.clone(this.root);\n    clonedFurniture.root = clonedRoot;\n\n    // IMPORTANT: Update unique ID\n    clonedFurniture.root.userData.entityId = this.generateId();\n    clonedFurniture.root.userData.type = 'Furniture';\n    clonedFurniture.root.userData.name = this.name;\n    return clonedFurniture;\n  }\n}\nclass Room {\n  constructor(name, width = 20, depth = 20) {\n    this.name = name;\n    this.width = width;\n    this.depth = depth;\n    this.furnitureList = [];\n    this.walls = [];\n    this.group = new THREE.Group();\n    this.group.userData = {\n      entityId: this.generateId(),\n      type: 'Room',\n      name: name\n    };\n\n    // Generate Walls automatically\n    this.generateWalls();\n  }\n  generateId() {\n    return Math.random().toString(36).substr(2, 9);\n  }\n  generateWalls() {\n    const h = 10; // Wall Height\n    const t = 0.5; // Wall Thickness\n\n    // Remove old walls if any\n    this.walls.forEach(w => this.group.remove(w.mesh));\n    this.walls = [];\n\n    // 1. Back Wall\n    const back = new Wall(this.width, h, t);\n    back.setPosition(0, h / 2, -this.depth / 2);\n    this.addWall(back);\n\n    // 2. Front Wall\n    const front = new Wall(this.width, h, t);\n    front.setPosition(0, h / 2, this.depth / 2);\n    this.addWall(front);\n\n    // 3. Left Wall\n    const left = new Wall(t, h, this.depth);\n    left.setPosition(-this.width / 2, h / 2, 0);\n    this.addWall(left);\n\n    // 4. Right Wall\n    const right = new Wall(t, h, this.depth);\n    right.setPosition(this.width / 2, h / 2, 0);\n    this.addWall(right);\n  }\n  addWall(wall) {\n    this.walls.push(wall);\n    this.group.add(wall.mesh);\n  }\n  addFurniture(furniture) {\n    this.furnitureList.push(furniture);\n    this.group.add(furniture.root);\n  }\n\n  /**\r\n   * Factory method to create instance from JSON data\r\n   */\n  static fromJSON(data) {\n    const room = new Room(data.name, data.width, data.depth);\n    if (data.furniture) {\n      data.furniture.forEach(itemData => {\n        const furniture = Furniture.fromJSON(itemData);\n        room.addFurniture(furniture);\n      });\n    }\n    return room;\n  }\n\n  /**\r\n   * Deep Clone\r\n   */\n  clone() {\n    const clonedRoom = new Room(this.name, this.width, this.depth);\n\n    // Clone Furniture\n    this.furnitureList.forEach(item => {\n      const clonedItem = item.clone();\n      clonedRoom.addFurniture(clonedItem);\n    });\n\n    // Copy room transform\n    clonedRoom.group.position.copy(this.group.position);\n    clonedRoom.group.userData.entityId = this.generateId();\n\n    // Note: Walls are generated by constructor, so they are fresh and correct size. \n    // No need to manually clone them unless we support custom wall modifications.\n\n    return clonedRoom;\n  }\n}\nclass Layout3D {\n  constructor(id, description) {\n    this.id = id;\n    this.description = description;\n    this.rooms = [];\n    this.cameraView = null; // Default camera settings\n    this.group = new THREE.Group();\n    this.group.userData = {\n      entityId: id,\n      type: 'Layout3D',\n      isMaster: true\n    };\n  }\n  addRoom(room) {\n    this.rooms.push(room);\n    this.group.add(room.group);\n  }\n\n  /**\r\n   * Async Load all assets\r\n   */\n  async loadAssets() {\n    const loader = new GLTFLoader();\n    const promises = [];\n    this.rooms.forEach(room => {\n      room.furnitureList.forEach(furniture => {\n        promises.push(furniture.loadModel(loader));\n      });\n    });\n    await Promise.all(promises);\n  }\n  static fromJSON(data) {\n    const layout = new Layout3D(data.id, data.name);\n    if (data.cameraView) {\n      layout.cameraView = data.cameraView;\n    }\n    if (data.rooms) {\n      data.rooms.forEach(roomData => {\n        const room = Room.fromJSON(roomData);\n        layout.addRoom(room);\n      });\n    }\n    return layout;\n  }\n  clone() {\n    const clonedLayout = new Layout3D(this.id, this.description);\n\n    // Copy camera view\n    if (this.cameraView) {\n      clonedLayout.cameraView = {\n        ...this.cameraView\n      };\n    }\n\n    // Deep clone rooms\n    this.rooms.forEach(room => {\n      const clonedRoom = room.clone();\n      clonedLayout.addRoom(clonedRoom);\n    });\n    clonedLayout.group.userData.isMaster = false;\n    return clonedLayout;\n  }\n}\n\n/**\r\n * Prototype Registry\r\n */\nclass LayoutRegistry {\n  constructor() {\n    this.masters = new Map();\n  }\n  registerMaster(id, layout) {\n    console.log(`[Registry] Registering Master Layout: ${id}`);\n    this.masters.set(id, layout);\n  }\n  getSessionClone(id) {\n    const master = this.masters.get(id);\n    if (!master) {\n      throw new Error(`Layout ${id} not found in registry.`);\n    }\n    // console.log(`[Registry] Creating Session Clone for: ${id}`);\n    return master.clone();\n  }\n}\nexport { Furniture, Wall, Room, Layout3D, LayoutRegistry };","map":{"version":3,"names":["THREE","GLTFLoader","SkeletonUtils","Wall","constructor","width","height","depth","geometry","BoxGeometry","material","MeshStandardMaterial","color","roughness","side","DoubleSide","mesh","Mesh","castShadow","receiveShadow","userData","entityId","generateId","type","Math","random","toString","substr","setPosition","x","y","z","position","set","clone","clonedWall","copy","rotation","Furniture","name","modelUrl","root","Group","add","setScale","scale","setRotation","loadModel","loader","gltf","loadAsync","model","scene","traverse","node","isMesh","box","Box3","setFromObject","size","Vector3","getSize","center","getCenter","sub","maxDim","max","scaleFactor","multiplyScalar","remove","console","log","err","error","fromJSON","data","furniture","clonedFurniture","clonedRoot","Room","furnitureList","walls","group","generateWalls","h","t","forEach","w","back","addWall","front","left","right","wall","push","addFurniture","room","itemData","clonedRoom","item","clonedItem","Layout3D","id","description","rooms","cameraView","isMaster","addRoom","loadAssets","promises","Promise","all","layout","roomData","clonedLayout","LayoutRegistry","masters","Map","registerMaster","getSessionClone","master","get","Error"],"sources":["C:/Users/chenx/Documents/sda/prototype/client/src/PrototypePattern.js"],"sourcesContent":["/**\r\n * 3D Real Estate Management System - Prototype Pattern Implementation\r\n * Definition of Prototype Interface and Entities\r\n */\r\n\r\nimport * as THREE from 'three';\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\r\nimport * as SkeletonUtils from 'three/examples/jsm/utils/SkeletonUtils';\r\n\r\n/**\r\n * Interface Component acting as the Prototype\r\n * All entities must implement a clone() method.\r\n */\r\n\r\nclass Wall {\r\n    constructor(width, height, depth) {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.depth = depth;\r\n\r\n        // Create textured/colored wall\r\n        const geometry = new THREE.BoxGeometry(width, height, depth);\r\n        const material = new THREE.MeshStandardMaterial({\r\n            color: 0xf5f5f5, // Off-white\r\n            roughness: 0.8,\r\n            side: THREE.DoubleSide\r\n        });\r\n\r\n        this.mesh = new THREE.Mesh(geometry, material);\r\n        this.mesh.castShadow = true;\r\n        this.mesh.receiveShadow = true;\r\n        this.mesh.userData = { entityId: this.generateId(), type: 'Wall' };\r\n    }\r\n\r\n    generateId() {\r\n        return Math.random().toString(36).substr(2, 9);\r\n    }\r\n\r\n    setPosition(x, y, z) {\r\n        this.mesh.position.set(x, y, z);\r\n    }\r\n\r\n    clone() {\r\n        const clonedWall = new Wall(this.width, this.height, this.depth);\r\n        clonedWall.mesh.position.copy(this.mesh.position);\r\n        clonedWall.mesh.rotation.copy(this.mesh.rotation);\r\n        clonedWall.mesh.userData.entityId = this.generateId();\r\n        return clonedWall;\r\n    }\r\n}\r\n\r\nclass Furniture {\r\n    constructor(name, type, modelUrl = null) {\r\n        this.name = name;\r\n        this.type = type;\r\n        this.modelUrl = modelUrl;\r\n\r\n        // Default Mesh (Box) until model is loaded\r\n        this.mesh = new THREE.Mesh(\r\n            new THREE.BoxGeometry(2, 2, 2),\r\n            new THREE.MeshStandardMaterial({ color: 0x888888 })\r\n        );\r\n        this.mesh.castShadow = true;\r\n        this.mesh.receiveShadow = true;\r\n        this.mesh.userData = { entityId: this.generateId(), type: 'Furniture', name: name };\r\n\r\n        this.root = new THREE.Group();\r\n        this.root.add(this.mesh); // Add placeholder initially\r\n        this.root.userData = { entityId: this.generateId(), type: 'Furniture', name: name };\r\n    }\r\n\r\n    generateId() {\r\n        return Math.random().toString(36).substr(2, 9);\r\n    }\r\n\r\n    setPosition(x, y, z) {\r\n        this.root.position.set(x, y, z);\r\n    }\r\n\r\n    setScale(x, y, z) {\r\n        this.root.scale.set(x, y, z);\r\n    }\r\n\r\n    setRotation(x, y, z) {\r\n        this.root.rotation.set(x, y, z);\r\n    }\r\n\r\n    /**\r\n     * Async Load Model\r\n     */\r\n    async loadModel(loader) {\r\n        if (!this.modelUrl) return;\r\n\r\n        try {\r\n            const gltf = await loader.loadAsync(this.modelUrl);\r\n            const model = gltf.scene;\r\n\r\n            // Enable shadows\r\n            model.traverse((node) => {\r\n                if (node.isMesh) {\r\n                    node.castShadow = true;\r\n                    node.receiveShadow = true;\r\n                }\r\n            });\r\n\r\n            // --- NORMALIZATION START ---\r\n            // Auto-Center and normalize scale to fit in a 1x1x1 box roughly, then apply this.scale.\r\n            // This prevents giant models from \"exploding\" the view.\r\n\r\n            const box = new THREE.Box3().setFromObject(model);\r\n            const size = new THREE.Vector3();\r\n            box.getSize(size);\r\n            const center = new THREE.Vector3();\r\n            box.getCenter(center);\r\n\r\n            // Center the model geometry\r\n            model.position.sub(center);\r\n            // Important: we shift the internal model, so the parent 'root' position is still valid.\r\n\r\n            // Optional: Auto-scale if model is huge or tiny\r\n            // Let's normalize it so the largest dimension is approx 1 unit, \r\n            // then we rely on this.root.scale to size it up to real-world meters.\r\n            // However, our JSON scale is roughly \"meters\" if the base is 1.\r\n            // Most GLTF models are in meters, but some are millimeters or arbitrary.\r\n\r\n            // Heuristic: If largest dim > 10, it's probably wrong scale (mm), or huge building.\r\n            // If < 0.1, it's probably too small.\r\n            // For safety in this demo, let's normalize base to max dim = 1.\r\n\r\n            const maxDim = Math.max(size.x, size.y, size.z);\r\n            if (maxDim > 0) {\r\n                const scaleFactor = 1.0 / maxDim;\r\n                model.scale.multiplyScalar(scaleFactor);\r\n            }\r\n\r\n            // --- NORMALIZATION END ---\r\n\r\n            // Replace placeholder with real model\r\n            this.root.remove(this.mesh);\r\n            this.root.add(model);\r\n            this.mesh = model;\r\n\r\n            console.log(`Loaded and normalized model for ${this.name}`);\r\n        } catch (err) {\r\n            console.error(`Failed to load model for ${this.name}`, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Factory method to create instance from JSON data\r\n     */\r\n    static fromJSON(data) {\r\n        const furniture = new Furniture(data.name, data.type, data.modelUrl);\r\n        if (data.position) furniture.setPosition(data.position.x, data.position.y, data.position.z);\r\n        if (data.rotation) furniture.setRotation(data.rotation.x, data.rotation.y, data.rotation.z);\r\n        if (data.scale) furniture.setScale(data.scale.x, data.scale.y, data.scale.z);\r\n        return furniture;\r\n    }\r\n\r\n    /**\r\n     * Deep Clone\r\n     */\r\n    clone() {\r\n        // Create new instance with same metadata\r\n        const clonedFurniture = new Furniture(this.name, this.type, this.modelUrl);\r\n\r\n        // Deep Clone the visual root using SkeletonUtils for GLTF support\r\n        const clonedRoot = SkeletonUtils.clone(this.root);\r\n\r\n        clonedFurniture.root = clonedRoot;\r\n\r\n        // IMPORTANT: Update unique ID\r\n        clonedFurniture.root.userData.entityId = this.generateId();\r\n        clonedFurniture.root.userData.type = 'Furniture';\r\n        clonedFurniture.root.userData.name = this.name;\r\n\r\n        return clonedFurniture;\r\n    }\r\n}\r\n\r\nclass Room {\r\n    constructor(name, width = 20, depth = 20) {\r\n        this.name = name;\r\n        this.width = width;\r\n        this.depth = depth;\r\n        this.furnitureList = [];\r\n        this.walls = [];\r\n        this.group = new THREE.Group();\r\n        this.group.userData = { entityId: this.generateId(), type: 'Room', name: name };\r\n\r\n        // Generate Walls automatically\r\n        this.generateWalls();\r\n    }\r\n\r\n    generateId() {\r\n        return Math.random().toString(36).substr(2, 9);\r\n    }\r\n\r\n    generateWalls() {\r\n        const h = 10; // Wall Height\r\n        const t = 0.5; // Wall Thickness\r\n\r\n        // Remove old walls if any\r\n        this.walls.forEach(w => this.group.remove(w.mesh));\r\n        this.walls = [];\r\n\r\n        // 1. Back Wall\r\n        const back = new Wall(this.width, h, t);\r\n        back.setPosition(0, h / 2, -this.depth / 2);\r\n        this.addWall(back);\r\n\r\n        // 2. Front Wall\r\n        const front = new Wall(this.width, h, t);\r\n        front.setPosition(0, h / 2, this.depth / 2);\r\n        this.addWall(front);\r\n\r\n        // 3. Left Wall\r\n        const left = new Wall(t, h, this.depth);\r\n        left.setPosition(-this.width / 2, h / 2, 0);\r\n        this.addWall(left);\r\n\r\n        // 4. Right Wall\r\n        const right = new Wall(t, h, this.depth);\r\n        right.setPosition(this.width / 2, h / 2, 0);\r\n        this.addWall(right);\r\n    }\r\n\r\n    addWall(wall) {\r\n        this.walls.push(wall);\r\n        this.group.add(wall.mesh);\r\n    }\r\n\r\n    addFurniture(furniture) {\r\n        this.furnitureList.push(furniture);\r\n        this.group.add(furniture.root);\r\n    }\r\n\r\n    /**\r\n     * Factory method to create instance from JSON data\r\n     */\r\n    static fromJSON(data) {\r\n        const room = new Room(data.name, data.width, data.depth);\r\n        if (data.furniture) {\r\n            data.furniture.forEach(itemData => {\r\n                const furniture = Furniture.fromJSON(itemData);\r\n                room.addFurniture(furniture);\r\n            });\r\n        }\r\n        return room;\r\n    }\r\n\r\n    /**\r\n     * Deep Clone\r\n     */\r\n    clone() {\r\n        const clonedRoom = new Room(this.name, this.width, this.depth);\r\n\r\n        // Clone Furniture\r\n        this.furnitureList.forEach(item => {\r\n            const clonedItem = item.clone();\r\n            clonedRoom.addFurniture(clonedItem);\r\n        });\r\n\r\n        // Copy room transform\r\n        clonedRoom.group.position.copy(this.group.position);\r\n        clonedRoom.group.userData.entityId = this.generateId();\r\n\r\n        // Note: Walls are generated by constructor, so they are fresh and correct size. \r\n        // No need to manually clone them unless we support custom wall modifications.\r\n\r\n        return clonedRoom;\r\n    }\r\n}\r\n\r\nclass Layout3D {\r\n    constructor(id, description) {\r\n        this.id = id;\r\n        this.description = description;\r\n        this.rooms = [];\r\n        this.cameraView = null; // Default camera settings\r\n        this.group = new THREE.Group();\r\n        this.group.userData = { entityId: id, type: 'Layout3D', isMaster: true };\r\n    }\r\n\r\n    addRoom(room) {\r\n        this.rooms.push(room);\r\n        this.group.add(room.group);\r\n    }\r\n\r\n    /**\r\n     * Async Load all assets\r\n     */\r\n    async loadAssets() {\r\n        const loader = new GLTFLoader();\r\n        const promises = [];\r\n\r\n        this.rooms.forEach(room => {\r\n            room.furnitureList.forEach(furniture => {\r\n                promises.push(furniture.loadModel(loader));\r\n            });\r\n        });\r\n\r\n        await Promise.all(promises);\r\n    }\r\n\r\n    static fromJSON(data) {\r\n        const layout = new Layout3D(data.id, data.name);\r\n        if (data.cameraView) {\r\n            layout.cameraView = data.cameraView;\r\n        }\r\n        if (data.rooms) {\r\n            data.rooms.forEach(roomData => {\r\n                const room = Room.fromJSON(roomData);\r\n                layout.addRoom(room);\r\n            });\r\n        }\r\n        return layout;\r\n    }\r\n\r\n    clone() {\r\n        const clonedLayout = new Layout3D(this.id, this.description);\r\n\r\n        // Copy camera view\r\n        if (this.cameraView) {\r\n            clonedLayout.cameraView = { ...this.cameraView };\r\n        }\r\n\r\n        // Deep clone rooms\r\n        this.rooms.forEach(room => {\r\n            const clonedRoom = room.clone();\r\n            clonedLayout.addRoom(clonedRoom);\r\n        });\r\n\r\n        clonedLayout.group.userData.isMaster = false;\r\n\r\n        return clonedLayout;\r\n    }\r\n}\r\n\r\n/**\r\n * Prototype Registry\r\n */\r\nclass LayoutRegistry {\r\n    constructor() {\r\n        this.masters = new Map();\r\n    }\r\n\r\n    registerMaster(id, layout) {\r\n        console.log(`[Registry] Registering Master Layout: ${id}`);\r\n        this.masters.set(id, layout);\r\n    }\r\n\r\n    getSessionClone(id) {\r\n        const master = this.masters.get(id);\r\n        if (!master) {\r\n            throw new Error(`Layout ${id} not found in registry.`);\r\n        }\r\n        // console.log(`[Registry] Creating Session Clone for: ${id}`);\r\n        return master.clone();\r\n    }\r\n}\r\n\r\nexport {\r\n    Furniture,\r\n    Wall,\r\n    Room,\r\n    Layout3D,\r\n    LayoutRegistry\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}