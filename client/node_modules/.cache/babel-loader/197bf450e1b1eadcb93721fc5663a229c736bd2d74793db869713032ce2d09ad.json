{"ast":null,"code":"import * as helpers from '../ParseHelpers';\nimport VertexParser from './vertex';\nexport default class Polyline {\n  constructor() {\n    this.ForEntityName = 'POLYLINE';\n  }\n  parseEntity(scanner, curr) {\n    var entity = {\n      type: curr.value,\n      vertices: []\n    };\n    curr = scanner.next();\n    while (!scanner.isEOF()) {\n      if (curr.code === 0) break;\n      switch (curr.code) {\n        case 10:\n          // always 0\n          break;\n        case 20:\n          // always 0\n          break;\n        case 30:\n          // elevation\n          break;\n        case 39:\n          // thickness\n          entity.thickness = curr.value;\n          break;\n        case 40:\n          // start width\n          break;\n        case 41:\n          // end width\n          break;\n        case 70:\n          entity.shape = (curr.value & 1) !== 0;\n          entity.includesCurveFitVertices = (curr.value & 2) !== 0;\n          entity.includesSplineFitVertices = (curr.value & 4) !== 0;\n          entity.is3dPolyline = (curr.value & 8) !== 0;\n          entity.is3dPolygonMesh = (curr.value & 16) !== 0;\n          entity.is3dPolygonMeshClosed = (curr.value & 32) !== 0; // 32 = The polygon mesh is closed in the N direction\n          entity.isPolyfaceMesh = (curr.value & 64) !== 0;\n          entity.hasContinuousLinetypePattern = (curr.value & 128) !== 0;\n          break;\n        case 71:\n          // Polygon mesh M vertex count\n          break;\n        case 72:\n          // Polygon mesh N vertex count\n          break;\n        case 73:\n          // Smooth surface M density\n          break;\n        case 74:\n          // Smooth surface N density\n          break;\n        case 75:\n          // Curves and smooth surface type\n          break;\n        case 210:\n          entity.extrusionDirection = helpers.parsePoint(scanner);\n          break;\n        default:\n          helpers.checkCommonEntityProperties(entity, curr, scanner);\n          break;\n      }\n      curr = scanner.next();\n    }\n    entity.vertices = parsePolylineVertices(scanner, curr);\n    return entity;\n  }\n}\nfunction parsePolylineVertices(scanner, curr) {\n  const vertexParser = new VertexParser();\n  const vertices = [];\n  while (!scanner.isEOF()) {\n    if (curr.code === 0) {\n      if (curr.value === 'VERTEX') {\n        vertices.push(vertexParser.parseEntity(scanner, curr));\n        curr = scanner.lastReadGroup;\n      } else if (curr.value === 'SEQEND') {\n        parseSeqEnd(scanner, curr);\n        break;\n      }\n    }\n  }\n  return vertices;\n}\nfunction parseSeqEnd(scanner, curr) {\n  const entity = {\n    type: curr.value\n  };\n  curr = scanner.next();\n  while (!scanner.isEOF()) {\n    if (curr.code == 0) break;\n    helpers.checkCommonEntityProperties(entity, curr, scanner);\n    curr = scanner.next();\n  }\n  return entity;\n}\n;","map":{"version":3,"names":["helpers","VertexParser","Polyline","constructor","ForEntityName","parseEntity","scanner","curr","entity","type","value","vertices","next","isEOF","code","thickness","shape","includesCurveFitVertices","includesSplineFitVertices","is3dPolyline","is3dPolygonMesh","is3dPolygonMeshClosed","isPolyfaceMesh","hasContinuousLinetypePattern","extrusionDirection","parsePoint","checkCommonEntityProperties","parsePolylineVertices","vertexParser","push","lastReadGroup","parseSeqEnd"],"sources":["C:/Users/chenx/Documents/sda/prototype/client/node_modules/dxf-parser/dist/entities/polyline.js"],"sourcesContent":["import * as helpers from '../ParseHelpers';\nimport VertexParser from './vertex';\nexport default class Polyline {\n    constructor() {\n        this.ForEntityName = 'POLYLINE';\n    }\n    parseEntity(scanner, curr) {\n        var entity = { type: curr.value, vertices: [] };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10: // always 0\n                    break;\n                case 20: // always 0\n                    break;\n                case 30: // elevation\n                    break;\n                case 39: // thickness\n                    entity.thickness = curr.value;\n                    break;\n                case 40: // start width\n                    break;\n                case 41: // end width\n                    break;\n                case 70:\n                    entity.shape = (curr.value & 1) !== 0;\n                    entity.includesCurveFitVertices = (curr.value & 2) !== 0;\n                    entity.includesSplineFitVertices = (curr.value & 4) !== 0;\n                    entity.is3dPolyline = (curr.value & 8) !== 0;\n                    entity.is3dPolygonMesh = (curr.value & 16) !== 0;\n                    entity.is3dPolygonMeshClosed = (curr.value & 32) !== 0; // 32 = The polygon mesh is closed in the N direction\n                    entity.isPolyfaceMesh = (curr.value & 64) !== 0;\n                    entity.hasContinuousLinetypePattern = (curr.value & 128) !== 0;\n                    break;\n                case 71: // Polygon mesh M vertex count\n                    break;\n                case 72: // Polygon mesh N vertex count\n                    break;\n                case 73: // Smooth surface M density\n                    break;\n                case 74: // Smooth surface N density\n                    break;\n                case 75: // Curves and smooth surface type\n                    break;\n                case 210:\n                    entity.extrusionDirection = helpers.parsePoint(scanner);\n                    break;\n                default:\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        entity.vertices = parsePolylineVertices(scanner, curr);\n        return entity;\n    }\n}\nfunction parsePolylineVertices(scanner, curr) {\n    const vertexParser = new VertexParser();\n    const vertices = [];\n    while (!scanner.isEOF()) {\n        if (curr.code === 0) {\n            if (curr.value === 'VERTEX') {\n                vertices.push(vertexParser.parseEntity(scanner, curr));\n                curr = scanner.lastReadGroup;\n            }\n            else if (curr.value === 'SEQEND') {\n                parseSeqEnd(scanner, curr);\n                break;\n            }\n        }\n    }\n    return vertices;\n}\nfunction parseSeqEnd(scanner, curr) {\n    const entity = { type: curr.value };\n    curr = scanner.next();\n    while (!scanner.isEOF()) {\n        if (curr.code == 0)\n            break;\n        helpers.checkCommonEntityProperties(entity, curr, scanner);\n        curr = scanner.next();\n    }\n    return entity;\n}\n;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}